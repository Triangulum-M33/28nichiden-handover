%% Generated by Sphinx.
\def\sphinxdocclass{jsbook}
\documentclass[letterpaper,10pt,dvipdfmx]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=49336sp\relax

\usepackage[margin=1in,marginparwidth=0.5in,dvipdfm]{geometry}


\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}

\usepackage{times}

\usepackage{longtable}
\usepackage{sphinx}

\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\renewcommand{\contentsname}{目次:}

\renewcommand{\figurename}{図}
\renewcommand{\tablename}{TABLE}
\renewcommand{\literalblockname}{LIST}

\def\pageautorefname{ページ}

\setcounter{tocdepth}{1}



\title{Nichiden Documentation}
\date{3月 07, 2017}
\release{0.1}
\author{Kenichi Ito}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{リリース}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{東京大学地文研究会天文部 日電引き継ぎ}
\label{\detokenize{main:}}\label{\detokenize{main::doc}}\label{\detokenize{main:id1}}\begin{itemize}
\item {} 
更新: 2017/03/04 Kenichi Ito(nichiden\_27)

\end{itemize}

日電の引き継ぎ文書です。ソースは全て公開しますので、ご自由に修正・追記してください。

\sphinxincludegraphics{{88x31}.png}


\section{冒頭部の情報について}
\label{\detokenize{main:}}\label{\detokenize{main:id2}}
各資料の冒頭部分には、「書いた人」「更新日時」「実行に必要な知識・技能」「タスクの重さ or 難易度」「タスクの必須度 or 情報の必須度」といった項目が示されています。


\section{実行に必要な知識・技能}
\label{\detokenize{main:}}\label{\detokenize{main:id3}}
資料で解説しているタスクや知識を実践するのに必要な知識などです。自分が理解できそうな資料を探したり、作業をするために何を身につけるべきか判断したりする際に参考にしてください。


\section{タスクの重さ}
\label{\detokenize{main:}}\label{\detokenize{main:id4}}
タスク関連の記事に付いています。
\begin{itemize}
\item {} 
1: 数時間で可能

\item {} 
2: 数日かかる

\item {} 
3: 数週間

\item {} 
4: 一月はかかる

\item {} 
5: 準備だけで数ヶ月

\end{itemize}

の5段階です。作業計画を立てる際などにご覧ください。

ただし、各代の方針によって、個々のタスクの重さは変動することに注意しましょう。


\section{難易度}
\label{\detokenize{main:}}\label{\detokenize{main:id5}}
技術情報などをまとめた記事に付いています。
\begin{itemize}
\item {} 
1: 常識の範囲

\item {} 
2: 少しやれば可能

\item {} 
3: 練習・勉強が必要

\item {} 
4: 分野に慣れてればできる

\item {} 
5: 得意分野ならどうぞ

\end{itemize}

学んでおきたい分野の大枠を掴むのに利用してください。


\section{タスクの必須度}
\label{\detokenize{main:}}\label{\detokenize{main:id6}}
タスク関連の記事に付いています。
\begin{itemize}
\item {} 
1: よほど暇なら

\item {} 
2: たまにやるべき

\item {} 
3: 年による

\item {} 
4: 毎年やるべき

\item {} 
5: しないとプラネ終了

\end{itemize}

今年の日電で何をやるか決める手助けになるかもしれません。


\section{情報の必須度}
\label{\detokenize{main:}}\label{\detokenize{main:id7}}
技術情報などをまとめた記事に付いています。
\begin{itemize}
\item {} 
1: 趣味レベル

\item {} 
2: 知ってると楽

\item {} 
3: 必要な場合がある

\item {} 
4: 担当者には必須

\item {} 
5: 全員必須

\end{itemize}


\chapter{プロジェクト マネジメント}
\label{\detokenize{management:}}\label{\detokenize{management::doc}}\label{\detokenize{management:id1}}\begin{itemize}
\item {} 
書いた人: Kenichi Ito(nichiden\_27)

\item {} 
更新日時: 2017/02/18

\item {} 
実行に必要な知識・技能: 特になし

\item {} 
タスクの重さ: 3: 数週間

\item {} 
タスクの必須度: 4: 毎年やるべき

\end{itemize}


\section{概要}
\label{\detokenize{management:}}\label{\detokenize{management:id2}}
日電長向けの内容です。日電の仕事をどう進めていくかなどを書きます。


\section{チーム編成}
\label{\detokenize{management:}}\label{\detokenize{management:id3}}

\subsection{連絡手段を決める}
\label{\detokenize{management:}}\label{\detokenize{management:id4}}
27ではSlackを使用した。日電は作業内容が多岐にわたるため、一つのチャットグループでは話題が混乱してしまう。LINEでも多数のグループを立てることで対応はできるが、管理が困難になるので最初からチームチャットを導入しておくことをお勧めする。

以下は27Slackの最終的なチャンネル構成である。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}acrab ... 星座絵アプリ}
\PYG{c+c1}{\PYGZsh{}dome ... ドームコンソール}
\PYG{c+c1}{\PYGZsh{}general ... 総合}
\PYG{c+c1}{\PYGZsh{}ginga ... ぎんとう}
\PYG{c+c1}{\PYGZsh{}haisen ... 配線}
\PYG{c+c1}{\PYGZsh{}hojyotou ... 補助投}
\PYG{c+c1}{\PYGZsh{}ittou ... いっとう}
\PYG{c+c1}{\PYGZsh{}log ... 活動記録}
\PYG{c+c1}{\PYGZsh{}nissyu\PYGZhy{}idohen ... 日周緯度変}
\PYG{c+c1}{\PYGZsh{}notifications ... 通知を流す用}
\PYG{c+c1}{\PYGZsh{}parts ... 部品管理}
\PYG{c+c1}{\PYGZsh{}piscium ... 星座絵無線機}
\PYG{c+c1}{\PYGZsh{}random ... 雑談}
\PYG{c+c1}{\PYGZsh{}seizae ... 星座絵}
\end{sphinxVerbatim}

Slackの特徴の一つに、他のWebサービスとの豊富な連携がある。27では、ToDoリストを共有できるTrelloやGitHubを使用した。通知がSlackで一覧できるので、進捗の共有が簡単になる。

余裕があれば、進捗を煽るBotなどを作成しても面白いかもしれない。


\subsection{目標を設定する}
\label{\detokenize{management:}}\label{\detokenize{management:id5}}
日電のやることは毎年そう変わらないが、できれば先年までと違うことに挑戦するとよい。ただし、新しい製品や機能には不具合や故障が付き物 であり、早期に目標を設定して動き始めることが重要だ。

前年度までに壊れてしまったものや、部員・観客へのインタビューで不満が多く寄せられた部分などが、新たな目標の候補となるだろう。


\subsection{担当を決める}
\label{\detokenize{management:}}\label{\detokenize{management:id6}}
日電の仕事の特質は、種類が多く、それぞれの作業は個人作業になりやすい ことである。また人数も限られているので、各自の責任感を高める意味でも早期に担当を振っておくべきだろう。これには、日電員が作業に向けて勉強するにあたり、個々の課題を明確にするという利点もある。


\subsection{スケジュールを決める}
\label{\detokenize{management:}}\label{\detokenize{management:id7}}
進捗は必ず遅れるものだが、だからと言ってスケジュールを切らずに闇雲に進めるのは大変危険である。最低限、どの期間に何をするかの大枠は示しておきたい。27日電での例は以下の通り。
\begin{itemize}
\item {} 
準備期間 〜8/1(Sセメ試験)

\item {} 
試作期間 8/2〜9/25(夏休み終了)

\item {} 
製作期間 9/26〜10/31

\item {} 
動作試験 11/1〜11/24(駒場祭前日)

\end{itemize}

もちろん、実際の作業に入った後の進捗の把握や再検討は、日電長が随時やっておく必要がある。


\section{作業が始まったら}
\label{\detokenize{management:}}\label{\detokenize{management:id8}}

\subsection{夜間}
\label{\detokenize{management:}}\label{\detokenize{management:id9}}
日電は個人プレーが多いので夜間への参加は必須ではないが、他の投影機は随時日電のサポートを必要とするので最低一人は出ておくのが望ましい。

また、作業で得られた進捗は、箇条書きなどにまとめて日電全員に報告 するとよい。作業に参加していないメンバーが現状を把握できる上、日電長自身も進捗を目に見える形で確認できる。


\subsection{卒検・リハ}
\label{\detokenize{management:}}\label{\detokenize{management:id10}}
卒検やリハでは、ドームを膨らませて投影機を配置し、点灯させる。この間の配線は日電が全て行うので、大変仕事が多くかつ責任が重い。この二日間だけは日電メンバーを全員揃える のが重要だ。前々から日程は判明しているはずなので、各自の予定を確認しておこう。


\chapter{日周緯度変(日周緯度変換機構)}
\label{\detokenize{nissyu-idohen/kikou:}}\label{\detokenize{nissyu-idohen/kikou::doc}}\label{\detokenize{nissyu-idohen/kikou:id1}}\begin{itemize}
\item {} 
書いた人: Kenichi Ito(nichiden\_27)

\item {} 
更新日時: 2017/03/03

\item {} 
実行に必要な知識・技能: 歯車機構

\item {} 
タスクの重さ: 5: 準備だけで数ヶ月

\item {} 
タスクの必須度: 2: たまにやるべき

\item {} 
元資料
\begin{itemize}
\item {} 
\sphinxcode{saitama.pdf} by 荒田 実樹(nichiden\_23)

\end{itemize}

\end{itemize}


\section{概要}
\label{\detokenize{nissyu-idohen/kikou:}}\label{\detokenize{nissyu-idohen/kikou:id2}}
日電の正式名称「日周緯度変・電源パート」から分かる通り、日電の本来の任務は日周緯度変装置を動作させることです。この記事では、日周緯度変装置自体に関しての情報をまとめます。


\section{構成}
\label{\detokenize{nissyu-idohen/kikou:}}\label{\detokenize{nissyu-idohen/kikou:id3}}
日周緯度変の役割は、プラネタリウムにおいて日周運動を再現する、あるいは(仮想的な)観測地の緯度を変更することである。なお、天文部の現在のプラネタリウムには歳差軸はない。

日周緯度変は大きく
\begin{itemize}
\item {} 
日周ギヤボックス

\item {} 
緯度変ギヤボックス

\end{itemize}

の2つに分かれ、それぞれに対応するステッピングモーターが搭載されている。

このステッピングモーターは一個数万円するものだが、本番中に劣化するので数年おきに買い換えられている。高価な割に\sphinxstylestrong{ケーブルが切れやすい} ので、取り扱う際は十分な注意を要する。

ギヤボックスはどちらも\sphinxstylestrong{10年以上前に製作された} ものである。製作年度に関して確かと言える情報は見つかっていないが、緯度は1994年の05主投、日周は2000年前後で製作されたようだ。

これほどの機構を再現できる技術が失われたため、かなりの長期間作り変えられていない。ただし、いつかは必ず壊れてしまうものであり、\sphinxstylestrong{なるべく早期に予備を製作すべき} だろう。日周緯度変の製作に成功すれば、天文部の歴史に名が残ることは間違いない。

特に緯度変に関しては、軸が摩耗していたり、ギアの噛み合わせが悪かったりして、
緯度を動かし続けるとある角度でかごしい全体が「揺れる」ことがある。この点は早急に改善が必要である。

ギヤボックス周辺の可動部分には\sphinxstylestrong{定期的にグリスを塗るか、潤滑油を差しておく} ことが望ましい。ただし2017年現在、機構部分の保守作業の大部分は、\sphinxstylestrong{かごしいの作業の過程で行われている。} ごきぶりやしいたけとの接続も彼らの方がより把握しているはずなので、任せておいて問題はないだろう。


\section{歯車機構と減速比}
\label{\detokenize{nissyu-idohen/kikou:}}\label{\detokenize{nissyu-idohen/kikou:id4}}
日周緯度変を自在に操るには各ギヤ比を知っておく事が必要である。

もちろん実物を見れば調べられるのだが、それなりに面倒だったので同じ手間を繰り返さないよう図に各ギヤの歯の数を載せておく。また、「正の向き(時計回り)」にモーターを回した時に各ギヤがどちら向きに回るかも載せておく。

\sphinxincludegraphics{{nissyuuidohen_gear}.png}

図に書いてあるギヤの歯の数からギヤ比を計算すると、
\begin{equation*}
\begin{split}\begin{aligned}
\frac{1}{80}\times\frac{25}{80}\times\frac{18}{64}=\frac{9}{8192}
&&\text{緯度変} \\
\frac{1}{50}\times\frac{20}{100}=\frac{1}{250}
&&\text{日周}\end{aligned}
\end{split}
\end{equation*}
となる。なお、これらのギヤの歯の数は動かしながら手で数えたので、もしかすると数え間違いがあるかもしれない。あまり過信しないよう。

つまり、各軸をある角速度で回したい場合、緯度変の場合は\sphinxcode{8192/9}を、日周の場合は\sphinxcode{250}をそれぞれ掛ければモーターが出力すべき角速度が求まる。日周緯度変関連のソースコードで8192や250といった定数が登場するのは、この減速比の変換をするためである。


\section{モーターの角速度}
\label{\detokenize{nissyu-idohen/kikou:}}\label{\detokenize{nissyu-idohen/kikou:id5}}
ステッピングモーターは速度を自由に設定できるが、もちろん上限はある。緯度変更モジュール単体で試したところ、緯度モーターの最高角速度は\(3500 deg/s\)程度であった。

この速度をかごしいの速度に換算すると \(3500/(8192/9)=3.84 deg/s\) となる。1度動かすのに0.26秒、南北の反転に46.8秒ほどという計算だ。

ただし、この\(3500 deg/s\)という速度は速度を徐々に上げていった場合の最高速度であり、停止した状態から回転させる場合は\(1800 deg/s\)程度が限度だと思われる。この場合かごしいの速度は\(1800/(8192/9)=1.98 deg/s\)となり、1度動かすのに0.5秒、南北反転には1分半かかることになる。

また、実際にかごしいを載せた場合や、主投影機を全て設置した場合など、回すものの重量によってさらに実際の速度は低下するので注意すること。


\chapter{日周緯度変(さいたま)}
\label{\detokenize{nissyu-idohen/saitama:}}\label{\detokenize{nissyu-idohen/saitama::doc}}\label{\detokenize{nissyu-idohen/saitama:id1}}\begin{itemize}
\item {} 
書いた人: Kenichi Ito(nichiden\_27)

\item {} 
更新日時: 2017/02/26

\item {} 
実行に必要な知識・技能: AVRマイコン、電子回路

\item {} 
タスクの重さ: 3: 数週間

\item {} 
タスクの必須度: 3: 年による

\item {} 
元資料
\begin{itemize}
\item {} 
\sphinxcode{日周・緯度変資料.pdf} by 岩滝宗一郎(nichiden\_22)

\item {} 
\sphinxcode{saitama.pdf} by 荒田 実樹(nichiden\_23)

\end{itemize}

\end{itemize}


\section{概要}
\label{\detokenize{nissyu-idohen/saitama:}}\label{\detokenize{nissyu-idohen/saitama:id2}}
日周緯度変コントローラ「さいたま」の使い方や仕組みなどを説明します。壊れて部品交換が必要になった・新しいさいたまを作りたい際に参照してください。


\section{沿革}
\label{\detokenize{nissyu-idohen/saitama:}}\label{\detokenize{nissyu-idohen/saitama:id3}}
日周緯度変のステッピングモーターを回すには、モータドライバという回路が必要になる。駒場祭プラネではモータドライバと制御基板を内蔵した専用コントローラーを使っており、2002年の\href{http://twitter.com/fujita\_d\_h/status/254087988882046976}{13日周以降}今日に至るまで\sphinxstylestrong{「さいたま」} と呼ばれている。

「さいたま」や他の回路に使用するマイコンは長らくPICであったが、22日電で\sphinxstylestrong{AVR} が採用され、23日電、24日電でもこれを踏襲した。PIC時代はほとんどのプログラムがアセンブラで書かれていたが、AVRを使うようになってからはC言語が使われるようになった。

さいたまはたびたび作り変えられてきたが、現在使用しているのは22が製作した\sphinxstylestrong{さいたま6號} である。23は、さいたまをPCから制御するための装置「Ikebukuro」を導入した(Ikebukuroの資料参照)。24では基板を作り直し、その際マイコンを\sphinxstylestrong{ATmega} に変更したようだ。


\section{使い方}
\label{\detokenize{nissyu-idohen/saitama:}}\label{\detokenize{nissyu-idohen/saitama:id4}}
\sphinxincludegraphics{{saitama_connection}.jpg}

背面に日周・緯度用に二つのコネクタがあるので、専用ケーブル※を使ってそれぞれのモータに繋ぐ。次に、モータの電力を確保するため、電源装置から\sphinxstylestrong{24V} を右面のDCジャックから供給しよう。

※コネクタはELコネクタ(日本圧着)6極、ケーブルはVCTF0.5sq 5芯

\sphinxincludegraphics{{saitama_buttons}.png}

コントローラ前面には6つのスイッチがある。現在では{\hyperref[\detokenize{nissyu-idohen/ikebukuro::doc}]{\sphinxcrossref{\DUrole{doc}{外部制御}}}}でPCから動かす方がはるかに便利だが、PCが使えない緊急時や急いでいるときはこのスイッチを使えばよい。

ラベルを参照すれば大体の意味は分かることだろう。回転のON/OFFと方向はそれぞれの軸で独立しているが、回転速度は2軸で変えることはできない。\sphinxcode{外部制御ON/OFF}スイッチは、PCから操作したい場合にONにする。これがONになっているときは、さいたま側のスイッチに反応しなくなるので気をつけよう。


\section{電装}
\label{\detokenize{nissyu-idohen/saitama:}}\label{\detokenize{nissyu-idohen/saitama:id5}}
ケースの両側に付いているねじを全て外すと、さいたまの中身を確認できる。

\sphinxincludegraphics{{saitama_internal}.jpg}
\begin{itemize}
\item {} 
メイン基板
\begin{itemize}
\item {} 
\sphinxstylestrong{画像は23引き継ぎのものだが、この翌年に作り変えられているので注意}

\item {} 
マイコンがスイッチの状態を読取り、モータードライバにCW・CCWパルスを送信する

\item {} 
スイッチはあまり重要でなかったため、基板作り変えの際取り除かれた模様

\item {} 
2×3のピンヘッダは、AVRマイコンにプログラムを書き込むためのもの

\end{itemize}

\item {} 
モータードライバ基板
\begin{itemize}
\item {} 
CW・CCWパルスに応じてステッピングモータに電流を流す

\item {} 
既製品。割と高価だが、部室に未使用の買い置きがある

\end{itemize}

\item {} 
スイッチ基板
\begin{itemize}
\item {} 
トグルスイッチが配置されている

\item {} 
普通に使っている場合一番壊れやすい部分なのでたまに異常がないか見てあげよう

\end{itemize}

\end{itemize}


\section{プログラム}
\label{\detokenize{nissyu-idohen/saitama:}}\label{\detokenize{nissyu-idohen/saitama:id6}}
23代が\sphinxcode{nissyuido}ディレクトリ以下に使用したソースコードを残している。\sphinxcode{WinAVR}環境があれば\sphinxcode{default}ディレクトリに移動して\sphinxcode{\$ make}コマンドを打てばビルドされるとのことだ。

ただし、前述の通り\sphinxstylestrong{24代でマイコンを\sphinxcode{ATmega328P}に変更} しており、以前のコードを使用できるかは定かでない。作り変えをする際は、24代の方に問い合わせてみることも検討されたい。

以下のプログラム解説は、23荒田氏の作成されたドキュメントと同内容である。必要なら氏のPDFや、コード中のコメントなども併せて確認すると良いだろう。


\subsection{main.c}
\label{\detokenize{nissyu-idohen/saitama:main-c}}
\sphinxincludegraphics{{saitama_program_flow}.png}

プログラムの起点となる \sphinxcode{main} 関数が入っている。
プログラムの大まかな流れは図を参照。

プログラムは初期化(\sphinxcode{main.c} の \sphinxcode{init}関数)の後、メインループ(無限ループ)に入る。ただ、初期化の時にタイマ割り込みを設定しているため、100マイクロ秒ごとに現在メインループで実行されている内容に関係なく「タイマ割り込み」の内容が実行される。

メインループの処理内容は \sphinxcode{main.c} を、「タイマ割り込み」の処理内容は
\sphinxcode{motordrive.c} を参照されたい。

外部制御コマンドのフォーマットはここで処理している。


\subsection{motordrive.c}
\label{\detokenize{nissyu-idohen/saitama:motordrive-c}}
ここが最も重要な部分である。
ステッピングモーターのドライブ回路に定期的にパルスを送り、指定した速度でモーターを回す。

モーターを角速度\(Speed\)(コード中では\sphinxcode{m-\textgreater{}current\_speed} \([deg/s]\))で回すにはどうすればよいか考えてみよう。一回のパルスでモーターが回転する角度はモーターとドライブ回路によって決まっており、\(\mathrm{MotorStep}=0.72 \mathrm{deg}\)(コード中では\sphinxcode{MOTOR\_STEP} \([10^{-2}deg]\))である。

AVRのタイマ機能により、\sphinxcode{motordrive}関数は\(\mathrm{ControlPeriod}=100 \mu\mathrm{s}\) (コード中では\sphinxcode{CONTROL\_PERIOD} \([\mu\mathrm{s}]\))間隔で呼ばれる。 前回パルスを送ってからの経過時間を\(n\cdot\mathrm{ControlPeriod}\)とする(前回パルスを送ってから\(n\)回目の\sphinxcode{motordrive}の呼び出し; \(n\)はコード中では\sphinxcode{m-\textgreater{}count})。

このとき、簡単な考察により、\(n\cdot\mathrm{ControlPeriod}\cdot\mathrm{Speed}\ge\mathrm{MotorStep}\)の時に次のパルスを送ればよいことが分かる。

実際には、速度指定モード・角度指定モードがあったり、速度を徐々に変化させる処理を行っているので、もう少し複雑なプログラムになっている。

「速度を徐々に変化させる処理」であるが、今のところ、現在の速度と目標速度が一致しなければ一定の加速度を加えるという、比較的単純な制御になっている。
時間と速度をグラフで表すと図のようになる。赤線が指定した速度、青線が実際の速度である。このように速度を徐々に変化させるようにプログラムの改修を行ったので、もはや\sphinxstylestrong{「一旦回転を停止してから回転方向を変更する」必要はない。}

\sphinxincludegraphics{{saitama_program_speed}.png}

角度指定モードの、速度を下げ始めるタイミングについて。

プログラムが実行されている時点を時刻\(t_0\)とし、時刻\(t_1\)にモーターが停止するとする。 モーターの\(t_0\)における角速度を\(\omega_0\)とする。単位時間当たりのモーターの角速度の変化を \(\alpha\)とする。現在のプログラムでは、\sphinxcode{motordrive}が呼ばれるたびに速度を\(1 \mathrm{deg/s}\)ずつ増減するので、
\begin{equation*}
\begin{split}\alpha=\pm\frac{1 \mathrm{deg/s}}{\mathrm{ControlPeriod}}
\end{split}
\end{equation*}
である。モーターの時刻\(t\)における角度(位置)を\(\theta(t)\)とする。

時刻\(t\)におけるモーターの角速度と角度はそれぞれ
\begin{equation*}
\begin{split}\begin{aligned}
\omega(t)&=\omega_0+\alpha(t-t_0) \\
\theta(t)&=\theta(t_0)+\omega_0(t-t_0)+\frac{1}{2}\alpha(t-t_0)^2\end{aligned}
\end{split}
\end{equation*}
となる。 時刻\(t_1\)にモーターが停止、すなわち\(\omega(t_1)=0\)より、
\begin{equation*}
\begin{split}t_1-t_0=-\frac{\omega_0}{\alpha}
\end{split}
\end{equation*}
である。これを\(\theta(t_1)\)に代入すると、
\begin{equation*}
\begin{split}\begin{aligned}
\theta(t_1)&=\theta(t_0)-\frac{\omega_0^2}{\alpha}
+\frac{1}{2}\alpha\left(-\frac{\omega_0}{\alpha}\right)^2 \\
%&=\theta(t_0)+\left(-\frac{1}{\alpha}+\frac{1}{2\alpha}\right)\omega_0^2 \\
&=\theta(t_0)-\frac{1}{2\alpha}\omega_0^2\end{aligned}
\end{split}
\end{equation*}
を得る。

求めたい量は、現在角がどういう値になったら速度を下げ始めるか、その角度である。
つまり、\(\theta(t_1)-\theta(t_0)\)の値である:
\begin{equation*}
\begin{split}\begin{aligned}
\theta(t_1)-\theta(t_0)&=-\frac{1}{2\alpha}\omega_0^2 \\
&=\frac{1}{2\left(\frac{1 \mathrm{deg/s}}{\mathrm{ControlPeriod}}\right)}\omega_0^2 \\
&=\frac{\mathrm{ControlPeriod}}{2(1 \mathrm{deg/s})}\omega_0^2\end{aligned}
\end{split}
\end{equation*}
ステップ数に換算するために両辺を\(\mathrm{MotorStep}\)で割ると、
\begin{equation*}
\begin{split}\frac{\theta(t_1)-\theta(t_0)}{\mathrm{MotorStep}}
=\frac{\mathrm{ControlPeriod}}{2(1 \mathrm{deg/s})\mathrm{MotorStep}}\omega_0^2
\end{split}
\end{equation*}
を得る。

なお、コード中では\(\frac{\mathrm{MotorStep}}{\mathrm{ControlPeriod}}\)に\sphinxcode{MOTOR\_MAX\_SPEED}という名前を与えている。


\subsection{uart.c}
\label{\detokenize{nissyu-idohen/saitama:uart-c}}
外部とシリアル通信するための関数が記述されている。通信データのバッファリングを行っているが、この仕組みが正常に動いているかは検討の余地がある。


\subsection{timer.c}
\label{\detokenize{nissyu-idohen/saitama:timer-c}}
\sphinxcode{motordrive}関数を\(100\mu s\)間隔で呼び出すための設定を行う。
ぶっちゃけ、\sphinxcode{motordrive}関数をそのままタイマ割り込みハンドラにし
ても良い気がする。


\subsection{コンパイルするには}
\label{\detokenize{nissyu-idohen/saitama:}}\label{\detokenize{nissyu-idohen/saitama:id7}}
ソースコードを編集したら、書き込む前にコンパイルする必要がある。\sphinxcode{default}ディレクトリ以下に\sphinxcode{Makefile}が入っているので、\sphinxcode{Makefile}の意味が分かる人は利用すると良いだろう。

Makefileの意味が分からない人は、Atmel Studioだか何だか知らないが、適当にプロジェクトを作ってファイルを放り込んでコンパイルすればよろしい。その際、
\begin{itemize}
\item {} 
マイコンの種類は ATmega328P

\item {} 
クロック周波数は 16MHz: プリプロセッサの設定をいじって、\sphinxcode{F\_CPU=16000000UL}がpredefinedになるようにする。(コンパイラオプションとして\sphinxcode{-DF\_CPU=16000000UL}が渡されればOK)

\item {} 
言語規格はC99+GNU拡張(コンパイラオプションとして\sphinxcode{-std=gnu99}が渡されればOK)

\end{itemize}

となるように注意する。


\section{今後の展望}
\label{\detokenize{nissyu-idohen/saitama:}}\label{\detokenize{nissyu-idohen/saitama:id8}}
もしもさいたまを作り替えるようなら、もう少し強力なマイコンを搭載すること、センサー(後述)対応にすること、\sphinxstylestrong{通信経路} についてもっとしっかり考えること(\sphinxcode{RS-485}にするのか、全部\sphinxcode{RS-232}とUSBシリアル通信で統一するのか)が望ましい。

23代で相対角度指定が実装されたが(現在使われていない)、\sphinxstylestrong{絶対角度指定} があると良いだろう。つまり、投影される星空を見ながら日周緯度変を操作するのではなく、「緯度は何度、日周は何月何日何時」という形で指定できるようにする。

絶対角度指定のためには、角度センサーを設置して現在位置を取得するか、一ヶ所にフォトインタラプタなどを設置して初期位置を判別できるようにして、後はステッピングモーターのステップ数で現在位置を把握する、などの方法が考えられる。

いずれにせよ、さいたまを作り直す際に日周緯度変に設置したセンサーを接続することを考慮しておくとよいだろう。

PC側のソフトウエアだが、PCで操作する以上何らかのメリットが欲しい。
速度を柔軟に調節できるようにはなったが、操作性にはまだまだ改善の余地がある。
リアルタイムで操作するには、マウスよりもキーボード、欲を言えばタッチパネルでの操作の方がいい。いろいろ工夫してみると良いだろう。

もう一つの方向性として、操作の記録・再生が考えられる。
ボタン一つで一本のソフトをまるまる上映できると楽だろう。ただし、ソフトウエアを実装する手間、操作を記録しておく手間に見合うメリットがあるかよく考える必要がある。


\chapter{日周緯度変(Ikebukuro)}
\label{\detokenize{nissyu-idohen/ikebukuro:ikebukuro}}\label{\detokenize{nissyu-idohen/ikebukuro::doc}}\begin{itemize}
\item {} 
書いた人: Kenichi Ito(nichiden\_27)

\item {} 
更新日時: 2017/02/26

\item {} 
実行に必要な知識・技能: 電子回路

\item {} 
タスクの重さ: 2: 数日かかる

\item {} 
タスクの必須度: 3: 年による

\item {} 
元資料
\begin{itemize}
\item {} 
\sphinxcode{日周・緯度変資料.pdf} by 岩滝宗一郎(nichiden\_22)

\item {} 
\sphinxcode{saitama.pdf} by 荒田 実樹(nichiden\_23)

\end{itemize}

\end{itemize}


\section{概要}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id1}}
\sphinxincludegraphics{{ikebukuro}.jpg}

さいたま6號には、外部機器(PCなど)を接続して制御することが可能です。これをさいたまの「\sphinxstylestrong{外部制御}」と呼んでいます。

埼玉6號の外部制御端子は\sphinxcode{RS-485/Mini-DIN6}という規格・形状ですが、残念ながらこのままではPCに直接挿して外部制御することはできません。そこで、\sphinxcode{RS-485/Mini-DIN6}と\sphinxcode{USB}の変換を行うために製作されたのが、\sphinxstylestrong{変換モジュール\sphinxcode{Ikebukuro}} (埼玉と繋がっているかららしい...)です。

実際に日周緯度変を動かす際に関わりの多い部分なので、使い方や構造などを解説します。


\section{沿革}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id2}}
外部制御は、埼玉6號を製作した22代の時点で既に仕様に盛り込まれていた。ただし使用はされておらず、テストもされていない状態だった。続く23代で\sphinxcode{Ikebukuro}が導入され、\sphinxstylestrong{PCを使用しての日周緯度変制御を初めて行った}。

その後の24〜27代では日周緯度変を操作するアプリの開発を行なっており、通信には\sphinxcode{Ikebukuro}が使われ続けている。


\section{使い方}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id3}}
さいたま6號側面に通信用の端子(\sphinxcode{Mini-DIN6})があるので、ケーブルで\sphinxcode{Ikebukuro}の同じ端子に接続する。次に、\sphinxcode{Ikebukuro}のUSB端子(miniB)とPCのUSB端子をUSBケーブルで接続すれば準備完了である。

さいたま6號の外部制御スイッチをONにすれば、PCからの信号を待ち受ける状態になる。あとは日周緯度変用のアプリなどを起動してシリアルポートに接続すれば良い。


\section{電装}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id4}}

\subsection{通信方式}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id5}}
埼玉6號の外部制御端子は、電気的には\sphinxcode{RS-485}という規格に従っている。
\sphinxcode{RS-485}では、3本の線(A,B,GND)で半二重通信(双方向の通信ができるが、同時に両方向の通信は不可)ができる。ノイズに強く、長距離にも耐えられるらしい。

埼玉6號の側部にあるMini-DIN6コネクタのピンとの対応は、図のようになっている。

\sphinxincludegraphics{{ikebukuro-rs485}.png}


\subsection{内部基板}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id6}}
\sphinxcode{Ikebukuro}の中身は単なる変換モジュールであり、\sphinxcode{RS-485}と\sphinxcode{UART}の変換を行うIC(\sphinxcode{LTC485})と、USBとUARTの変換を行うモジュール(\sphinxcode{AE-UM232R})が載っているだけである。

\sphinxcode{AE-UM232R}に搭載されているUSB-UART変換チップ(FTDI社の\sphinxcode{FT232R}という、定番チップ)の関係で、利用するにはPC側にドライバが必要な場合がある。\href{http://www.ftdichip.com/Drivers/VCP.htm}{FTDI社のWebページ}から入手できるので、必要なら使用するPCにインストールしておこう。

また、このチップは初期状態から設定が書き換えられており、\sphinxcode{InvertRTS=1}となっている。この設計はFTDI社謹製の\sphinxcode{FT\_PROG}(Windows用)というツールで設定できる。

\sphinxcode{RS-485}は半二重なので、通信方向の切り替えが必要である。これは、シリアルポートのRTSピンを使用して行っている。

\sphinxcode{Ikebukuro}の基板の配線を図に載せる。なお、図には反映していないが、RTSの状態確認用にLEDを実装している。

\sphinxincludegraphics{{ikebukuro-circuit}.png}

\sphinxcode{AE-UM232R}はICソケットに差さっているので、容易に\sphinxcode{Ikebukuro}から取り外すことができる。他の回路のテストでUSBシリアル変換モジュールを使いたい時は、\sphinxcode{Ikebukuro}から\sphinxcode{AE-UM232R}を取り外して使うと良いだろう(実際、23代で惑星投影機の基板のテストに利用した。最終的にはXBeeで通信するのだが、デバッグ時は「信頼と安定の」FT232Rを利用しようというわけだ)。


\section{プロトコルとコマンド}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id7}}
外部制御モードではPCからさいたま6號に指令(コマンド)を送る。ここでは、コマンドを表す文字列のフォーマットを述べる。

このフォーマットを変更したいと思ったら、さいたま側のプログラムの\sphinxcode{main.c}とPC側のプログラムをいじればよい。


\subsection{各コマンドに共通するフォーマット}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id8}}
\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|}
\hline
\sphinxstylethead{\relax 
位置
\unskip}\relax &\sphinxstylethead{\relax 
0
\unskip}\relax &\sphinxstylethead{\relax 
1
\unskip}\relax &\sphinxstylethead{\relax 
2
\unskip}\relax &\sphinxstylethead{\relax 
3
\unskip}\relax &\sphinxstylethead{\relax 
4
\unskip}\relax &\sphinxstylethead{\relax 
...
\unskip}\relax \\
\hline
内容
&
\sphinxcode{\$}
&
\sphinxcode{W}
&
\sphinxstyleemphasis{addr}
&
\sphinxstyleemphasis{len}
&
\sphinxstyleemphasis{cmd}
&
...
\\
\hline\end{tabulary}



\bigskip\hrule{}\bigskip

\begin{itemize}
\item {} 
\sphinxstyleemphasis{addr}: 機器のアドレス (16進1桁; ‘\sphinxcode{0}’〜‘\sphinxcode{9}’, ‘\sphinxcode{A}’〜‘\sphinxcode{F}’)
\begin{itemize}
\item {} 
メイン基板上のディップスイッチで設定した値と一致させる

\item {} 
現在は\sphinxcode{0}が使われている

\item {} 
複数の機器を繋いだ時用のアドレスだが、使うことはないだろう

\end{itemize}

\item {} 
\sphinxstyleemphasis{len}: 以降のバイト数 (16進1桁; ‘\sphinxcode{0}’〜‘\sphinxcode{9}’, ‘\sphinxcode{A}’〜‘\sphinxcode{F}’)

\item {} 
\sphinxstyleemphasis{cmd}: コマンドの種類

\end{itemize}


\subsection{速度指定コマンド}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id9}}
\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|L|}
\hline
\sphinxstylethead{\relax 
位置
\unskip}\relax &\sphinxstylethead{\relax 
...
\unskip}\relax &\sphinxstylethead{\relax 
3
\unskip}\relax &\sphinxstylethead{\relax 
4
\unskip}\relax &\sphinxstylethead{\relax 
5
\unskip}\relax &\sphinxstylethead{\relax 
6
\unskip}\relax &\sphinxstylethead{\relax 
7..10
\unskip}\relax &\sphinxstylethead{\relax 
...
\unskip}\relax \\
\hline
内容
&
...
&
\sphinxcode{7}
&
\sphinxcode{V}
&
\sphinxstyleemphasis{motor}
&
\sphinxstyleemphasis{dir}
&
\sphinxstyleemphasis{speed}
&
...
\\
\hline\end{tabulary}



\bigskip\hrule{}\bigskip

\begin{itemize}
\item {} 
\sphinxstyleemphasis{len}: 以降のバイト数 = `\sphinxcode{7}` (7 byte)

\item {} 
\sphinxstyleemphasis{cmd}: コマンドの種類 = `\sphinxcode{V}`

\item {} 
\sphinxstyleemphasis{motor}: モーター (日周:‘\sphinxcode{D}’, 緯度:‘\sphinxcode{L}’)

\item {} 
\sphinxstyleemphasis{dir}: 回転方向 (時計回り:‘\sphinxcode{+}’, 反時計回り‘\sphinxcode{-}’)

\item {} 
\sphinxstyleemphasis{speed}: 回転速度{[}deg/s{]} (16進4桁; ‘\sphinxcode{0}’〜‘\sphinxcode{9}’, ‘\sphinxcode{A}’〜‘\sphinxcode{F}’)

\end{itemize}


\subsection{角度指定コマンド}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id10}}
\noindent\begin{tabulary}{\linewidth}{|L|L|L|L|L|L|L|L|}
\hline
\sphinxstylethead{\relax 
位置
\unskip}\relax &\sphinxstylethead{\relax 
...
\unskip}\relax &\sphinxstylethead{\relax 
3
\unskip}\relax &\sphinxstylethead{\relax 
4
\unskip}\relax &\sphinxstylethead{\relax 
5
\unskip}\relax &\sphinxstylethead{\relax 
6
\unskip}\relax &\sphinxstylethead{\relax 
7...12
\unskip}\relax &\sphinxstylethead{\relax 
13...16
\unskip}\relax \\
\hline
内容
&
...
&
\sphinxcode{D}
&
\sphinxcode{P}
&
\sphinxstyleemphasis{motor}
&
\sphinxstyleemphasis{dir}
&
\sphinxstyleemphasis{angle}
&
\sphinxstyleemphasis{speed}
\\
\hline\end{tabulary}



\bigskip\hrule{}\bigskip

\begin{itemize}
\item {} 
\sphinxstyleemphasis{len}: 以降のバイト数 = `\sphinxcode{D}` (13 byte)

\item {} 
\sphinxstyleemphasis{cmd}: コマンドの種類 = `\sphinxcode{P}`

\item {} 
\sphinxstyleemphasis{motor}   モーター (日周:‘\sphinxcode{D}’, 緯度:‘\sphinxcode{L}’)

\item {} 
\sphinxstyleemphasis{dir}     回転方向 (時計回り:‘\sphinxcode{+}’, 反時計回り‘\sphinxcode{-}’)

\item {} 
\sphinxstyleemphasis{angle}   回転角度{[}\(10^{-2}\)deg{]} (16進6桁; ‘\sphinxcode{0}’〜‘\sphinxcode{9}’, ‘\sphinxcode{A}〜‘\sphinxcode{F}’)

\item {} 
\sphinxstyleemphasis{speed}   回転速度{[}deg/s{]} (16進4桁; ‘\sphinxcode{0}’〜‘\sphinxcode{9}’, ‘\sphinxcode{A}’〜‘\sphinxcode{F}’)

\end{itemize}


\subsection{コマンド実例集}
\label{\detokenize{nissyu-idohen/ikebukuro:}}\label{\detokenize{nissyu-idohen/ikebukuro:id11}}
以上がさいたま外部制御コマンドの仕様だが、これだけでは少々分かりにくいはずなのでいくつか実例を挙げておく。
\begin{itemize}
\item {} 
緯度モーターを3000deg/sで時計回りに回す -\textgreater{} \sphinxcode{\$W07VL+0BB8}

\item {} 
日周モーターを1800deg/sで時計回りに90000deg回す -\textgreater{} \sphinxcode{\$W0DPD+8954400708}

\end{itemize}


\subsection{PC側のプログラム}
\label{\detokenize{nissyu-idohen/ikebukuro:pc}}
PC側からは、Ikebukuroが仮想COMポートに見えるので、そのCOMポートに対して上に述べたコマンドを書き込めば良い。この辺りの具体的な話は{\hyperref[\detokenize{nissyu-idohen/pc-software::doc}]{\sphinxcrossref{\DUrole{doc}{外部制御アプリの資料}}}}に譲る。


\chapter{日周緯度変(外部制御アプリ)}
\label{\detokenize{nissyu-idohen/pc-software:}}\label{\detokenize{nissyu-idohen/pc-software::doc}}\label{\detokenize{nissyu-idohen/pc-software:id1}}\begin{itemize}
\item {} 
書いた人: Kenichi Ito(nichiden\_27)

\item {} 
更新日時: 2017/03/04

\item {} 
実行に必要な知識・技能: シリアル通信、C\#

\item {} 
タスクの重さ: 3: 数週間

\item {} 
タスクの必須度: 4: 毎年やるべき

\end{itemize}


\section{概要}
\label{\detokenize{nissyu-idohen/pc-software:}}\label{\detokenize{nissyu-idohen/pc-software:id2}}
日周緯度変の{\hyperref[\detokenize{nissyu-idohen/ikebukuro::doc}]{\sphinxcrossref{\DUrole{doc}{外部制御}}}}には、大きな可能性があります。PCを使える以上かなり複雑な操作も自動化できるためです。

ただし、本番で日周緯度変を動かすのは人間である部員たち。
それも、プログラムの挙動を知っている日電員だけが操作するとは限りません(26・27と、かごしいにも日周緯度変操作を手伝って貰っています)。

誰にでも使いやすい日周緯度変外部制御アプリを作るために注意すべきことを書きます。


\section{沿革}
\label{\detokenize{nissyu-idohen/pc-software:}}\label{\detokenize{nissyu-idohen/pc-software:id3}}
\sphinxstylestrong{過去に開発されたアプリケーションが多数にのぼるため、{\hyperref[\detokenize{nissyu-idohen/pc-software-history::doc}]{\sphinxcrossref{\DUrole{doc}{外部制御アプリの歴史}}}}に分離する。}


\section{Ogoseの特徴と使い方}
\label{\detokenize{nissyu-idohen/pc-software:ogose}}
\sphinxcode{Ogose}は、27代日電で作成した、2017/03/01現在最新の外部制御アプリである。

特徴は{\hyperref[\detokenize{nissyu-idohen/pc-software-history::doc}]{\sphinxcrossref{\DUrole{doc}{沿革}}}}の方に文章で書いたので、ここでは簡単に箇条書きするにとどめる。

\sphinxincludegraphics{{ogose}.png}
\begin{itemize}
\item {} 
各軸4段階で速度を指定

\item {} 
回転中の速度変更が可能

\item {} 
回転の開始/停止はトグルボタン(押すたびにON/OFFが切り替わる)

\item {} 
フルスクリーン切り替えボタン

\item {} 
誤操作防止用の「公演モード」

\item {} 
キーボードでも操作可能

\item {} 
フリーソフトを使ってゲームコントローラに操作を割り当て可能

\end{itemize}


\subsection{基本操作}
\label{\detokenize{nissyu-idohen/pc-software:}}\label{\detokenize{nissyu-idohen/pc-software:id4}}
起動したら、まずは最上部からシリアルポートを選んで\sphinxstylestrong{接続ボタン} を押す。
さいたまを\sphinxcode{Ikebukuro}を介して繋いだだけの状態ならポートは一つしか出ないことがほとんどだが、複数出たとしても一つずつ試してモーターが動くかどうかで判断すればよい。

未接続のままコマンドを送る操作をした場合は、エラーメッセージとともに送信するコマンドが表示される。
接続していないことに気づけるようにする一方、わざと未接続にすることでコマンド送信のデバッグも可能だ。

実際に日周緯度変を動かすときは、左側と上側にある\sphinxstylestrong{速度切り替えボタン} から速度を選び、動かしたい方向のボタンをクリックする。
起動後に一度も速度を選んでいないときは、各軸とも「速い」速度が選択される。

回転開始ボタンは押すと「停止」に表示が切り替わり、再度押すと回転が停止する。
反対方向のボタンは「停止」するまでグレーアウトしてクリックに反応しない。これは、ボタンの表示がおかしくなるのを防ぐためである。

\sphinxstylestrong{フルスクリーンボタン} にチェックするとフルスクリーンになる。
画面全体が黒背景になるので、本番中はフルスクリーンが望ましい。
\sphinxstylestrong{公演モード} ボタンは、ONにすると警告が表示され日周を進めることしかできなくなる。

モーターの回転はキーボード操作でもできる。
\begin{itemize}
\item {} 
\sphinxcode{W}: 緯度+

\item {} 
\sphinxcode{A}: 日周戻す

\item {} 
\sphinxcode{S}: 緯度-

\item {} 
\sphinxcode{D}: 日周進める

\end{itemize}

と対応している。PCゲーマーには馴染みのある配置かと思う。

\sphinxcode{Ogose}のコードの解説は、たいへん長いので別記事とする。

-\textgreater{} {\hyperref[\detokenize{nissyu-idohen/pc-software-code::doc}]{\sphinxcrossref{\DUrole{doc}{Ogoseの実装解説}}}}


\section{通信プログラム}
\label{\detokenize{nissyu-idohen/pc-software:}}\label{\detokenize{nissyu-idohen/pc-software:id5}}

\subsection{シリアル通信の基本}
\label{\detokenize{nissyu-idohen/pc-software:}}\label{\detokenize{nissyu-idohen/pc-software:id6}}
\sphinxcode{Ikebukuro}の記事にある通り、パソコン側からは｀はシリアルポートとして見える。
よって、シリアルポートにアクセスするプログラムを書けばよい。

ポート名は、Windowsであれば\sphinxcode{COM1}や\sphinxcode{COM4}のように、「'\sphinxcode{COM}`+数字」の形式である。
Mac OS XやLinuxのようなUNIX環境であれば、\sphinxcode{/dev/tty.usbserial-A5017ABT}である。

シリアルポートの設定は、さいたま6號側のプログラム中に記述してある設定と一致させなければならない。
現時点での設定は、
\begin{itemize}
\item {} 
baud rate: 2400

\item {} 
parity: none

\item {} 
char bits: 8

\item {} 
stopbit: 1

\end{itemize}

である。baud rateはこの値である必然性はないので、変えても良い(さいたま6號のプログラムも一緒に変更すること！)。

通信経路の途中で\sphinxcode{RS485}を使っている関係上、シリアルポートには読み取りと書き込みのいずれか一方しかできない。

\sphinxcode{RS485}の通信方向の切り替えには、シリアルポートのRTS端子を使う。
RTSが\sphinxcode{HIGH}になるとパソコン側から日周緯度変側への通信ができ、\sphinxcode{LOW}になると逆方向の通信ができる。
コマンドを送信する直前にRTSを\sphinxcode{HIGH}にし、終了したら\sphinxcode{LOW}に戻すといいだろう。


\subsection{.Netでのシリアル通信}
\label{\detokenize{nissyu-idohen/pc-software:net}}
\sphinxcode{.Net Framework}を使う場合は、\sphinxcode{System.IO.Ports}名前空間以下にある\sphinxcode{SerialPort}クラスを利用すると便利である。
Mac OS XやLinuxでは\sphinxcode{.Net}のオープンソース実装である\sphinxcode{Mono}を利用できるが、\sphinxcode{Mono}においても同様である。

以下ではC\#のコード例を示す。

まず、ソースコードの冒頭に以下の文を書いておくと便利であろう:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{using} \PYG{n+nn}{System.IO.Ports}\PYG{p}{;}
\end{sphinxVerbatim}

通信を開始する前に、まずポートを開く：

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SerialPort} \PYG{n}{port} \PYG{p}{=} \PYG{k}{new} \PYG{n}{SerialPort}\PYG{p}{(}
  \PYG{n}{portName}\PYG{p}{:}\PYG{n}{portName}\PYG{p}{,}
  \PYG{n}{baudRate}\PYG{p}{:}\PYG{l+m}{2}\PYG{l+m}{4}\PYG{l+m}{0}\PYG{l+m}{0}\PYG{p}{,}
  \PYG{n}{parity}\PYG{p}{:}\PYG{n}{Parity}\PYG{p}{.}\PYG{n}{None}\PYG{p}{,}
  \PYG{n}{dataBits}\PYG{p}{:}\PYG{l+m}{8}\PYG{p}{,}
  \PYG{n}{stopBits}\PYG{p}{:}\PYG{n}{StopBits}\PYG{p}{.}\PYG{n}{One}
\PYG{p}{)}\PYG{p}{;}
\PYG{n}{port}\PYG{p}{.}\PYG{n}{Open}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

この後、\sphinxcode{port.IsOpen}により、ポートを開くのに成功したか確認しておこう。

実際に通信するには\sphinxcode{SerialPort.Write}メソッドを使う。プログラムを終了する際には、\sphinxcode{port.Close()}によりポートを閉じておく。


\subsection{他の言語でのシリアル通信}
\label{\detokenize{nissyu-idohen/pc-software:}}\label{\detokenize{nissyu-idohen/pc-software:id7}}
日電では23からC\#で外部制御アプリを開発してきたが、他の各種の言語でもシリアル通信を扱えるので記しておく。
\begin{itemize}
\item {} 
C, Lua: \href{https://github.com/ynezz/librs232/}{\sphinxcode{librs232}}

\item {} 
Lua: \sphinxcode{LuaSys}

\item {} 
Python: \href{http://pyserial.sourceforge.net/}{\sphinxcode{pySerial}}

\item {} 
Ruby: \href{http://ruby-serialport.rubyforge.org/}{\sphinxcode{ruby-serialport}}

\item {} 
Java: \sphinxcode{Java Communications API} / \sphinxcode{RXTX}(Windows)

\item {} 
JavaScript(Node.js): \href{https://www.npmjs.com/package/serialport}{\sphinxcode{serialport}}

\end{itemize}

それぞれの使い方やインストール方法についてはググって欲しい。


\subsection{ユーザインターフェース}
\label{\detokenize{nissyu-idohen/pc-software:}}\label{\detokenize{nissyu-idohen/pc-software:id8}}
日周緯度変をある程度誰でも動かせるようにするには、GUIは欠かせない。歴代日電では、GUI開発にWindows FormアプリケーションやWPFを用いてきた。
もちろん他にもGUIのフレームワークは星の数ほどあるが、時間も限られている以上、定番で枯れた技術を使うのが無難ではなかろうか。

一つの可能性としては、最近イケイケのWebアプリがある。
ChromeとJavaScriptをベースにデスクトップアプリを実現する\sphinxcode{Electron}など、ここ最近急速にシェアを伸ばしている技術もある。
もしあなたがそういった技術を得意としているなら、乗り換える価値はあるかもしれない。


\section{今後の展望}
\label{\detokenize{nissyu-idohen/pc-software:}}\label{\detokenize{nissyu-idohen/pc-software:id9}}
\sphinxstylestrong{コントロールの操作性} にはまだまだ改善の余地がある。
本番でリアルタイムの操作をするには、マウスよりもキーボードがいいし、タッチパネルやゲームコントローラーといった馴染みのある操作系も役に立つだろう。
ゲームコントローラーは27ではフリーソフトでキー操作と無理やり関連付けしたが、\sphinxcode{DirectInput}を使えば自前でも利用できる。

さらなる方向性として、\sphinxstylestrong{操作の記録・再生} が考えられる。
23や25で行ってきたことを発展させ、ボタン一つで一本のソフトをまるまる上映できるようになれば楽だろう。

ただし、当然ソフトの指示は毎年変わるので、開発の負担は増加する。
ライブ解説ではタイミングを人力で判断せねばならず、想定外の事態も起こりうる以上、全自動化への道は平坦ではない。
コストに見合うメリットが得られるような仕組みを、ぜひ考案してほしい。


\chapter{日周緯度変(外部制御アプリの歴史)}
\label{\detokenize{nissyu-idohen/pc-software-history:}}\label{\detokenize{nissyu-idohen/pc-software-history::doc}}\label{\detokenize{nissyu-idohen/pc-software-history:id1}}\begin{itemize}
\item {} 
書いた人: Kenichi Ito(nichiden\_27)

\item {} 
更新日時: 2017/03/04

\item {} 
実行に必要な知識・技能: 特になし

\item {} 
難易度: 2: 少しやれば可能

\item {} 
情報の必須度: 2: 知ってると楽

\item {} 
元資料
\begin{itemize}
\item {} 
\sphinxcode{引き継ぎと技術的補足：日周緯度変外部制御ユーザインタフェース.docx} by 紺野雄介(nichiden\_23)

\item {} 
\sphinxcode{ふじさわreadme.docx} by 池下 氏(nichiden\_24)

\item {} 
\sphinxcode{25の日周・緯度変について.docx} by 伊藤太陽(nichiden\_25)

\end{itemize}

\end{itemize}


\section{概要}
\label{\detokenize{nissyu-idohen/pc-software-history:}}\label{\detokenize{nissyu-idohen/pc-software-history:id2}}
{\hyperref[\detokenize{nissyu-idohen/pc-software::doc}]{\sphinxcrossref{\DUrole{doc}{日周緯度変(外部制御アプリ)}}}}から歴代外部制御アプリケーションの紹介を分離した記事です。

現在は実装されていない機能があったりと、それぞれに特徴があるので、把握しておくと今後の改善に繋がるかもしれません。


\section{Tokyo Terminal(2012)}
\label{\detokenize{nissyu-idohen/pc-software-history:tokyo-terminal-2012}}
\sphinxincludegraphics{{tokyoterminal}.png}

23代荒田氏が制作した。外部制御は23代で初使用されたが、\sphinxcode{Tokyo Terminal}はそのテスト用に書かれたものである。

氏の環境がMac OSだったため、Macでしか動作しない。23代の作業データの\sphinxcode{日周緯度変外部制御/Saitama6Brain/}以下にソースファイルやアプリ本体があるが、最新のMac OSでは対応していない旨が表示され起動しなかった。

これ以降の外部制御アプリは全てWindows向けに開発されたものだ。Mac向けに開発する必要に迫られることがもしあれば、\sphinxcode{Tokyo Terminal}のコードが参考になるかもしれない(Mac開発の経験があれば一から書いた方が早い可能性も大いにあるが...)。


\section{NisshuidohenController2(2012)}
\label{\detokenize{nissyu-idohen/pc-software-history:nisshuidohencontroller2-2012}}
\sphinxincludegraphics{{nisshuidohencontroller2}.png}

23代紺野氏の作。\sphinxcode{Tokyo Terminal}がMac専用だったため、Windows版として開発された。開発言語はC\#で、Windows Formアプリケーション(\sphinxcode{System.Windows.Forms}名前空間を使用)である。

\sphinxcode{Tokyo Terminal}と共通の機能が多いが、大きな違いは\sphinxstylestrong{操作の記録・再生ができる} ことである。「速度指定」か「角度指定」かを選択して「記録」ボタンを押すと右のスペースに送るコマンドが表示され、同時に\sphinxcode{Instruction.txt}というファイルにも保存される。

あらかじめ必要なコマンドを記録しておいて面倒な操作なしに再実行できる画期的な機能である...と言いたいところだが、\sphinxstylestrong{表示されるのはコマンドだけ}(数値は16進数)なので、肝心の再生部分が手軽に利用できるとは言い難い。

「高速」「低速」のボタンで出る角速度は以下の数値に固定されている。なお、上半分で入力する角速度はモーターのもの、以下の角速度はギアによる減速後のかごしいのものなので注意。
\begin{itemize}
\item {} 
日周高速ボタン: 4 deg/s

\item {} 
日周低速ボタン: 1 deg/s

\item {} 
緯度高速ボタン: 1 deg/s

\item {} 
緯度低速ボタン: 0.5 deg/s

\end{itemize}

この数値は後発の\sphinxcode{Fujisawa}、\sphinxcode{Chichibu}でも同じものが使われている。

当時の日周緯度変は相応のスキルのある日電員が操作しており、自分たちで使うための最小限の機能を盛り込んだという印象だ。実際、本番中に使用したのは「高速」などのボタンだけだったという。

将来これを使うことはなさそうだが、速度・角度・方向に対応するコマンドを表示してくれるので、デバッグ用の計算機にはなるかもしれない。


\section{Fujisawa(2013)}
\label{\detokenize{nissyu-idohen/pc-software-history:fujisawa-2013}}
\sphinxincludegraphics{{fujisawa}.png}

24池下氏によるもの。引き続きC\#によるWindowsアプリだが、UIのフレームワークに\sphinxcode{Windows Presentation Foundation(WPF)}を使用している。

WPFの詳細についてはググって欲しいが、デザインとコードを分けて書くことができるというのが大きな利点である。つまり、内部の動作を崩さずに見た目だけをいじり倒せるのだ。その甲斐あってか、23のUIに比べデザイン面が大きく改善した。コマンド文字列を生成するコードは\sphinxcode{fujisawa/NisshuidohenController.cs}でクラスにまとめて定義されている。

日周緯度変にPCを使うとき、一番問題になるのは画面が光ることだ。PCは画面も大きいし、そのために星がかき消されてしまいかねない。\sphinxcode{Fujisawa}は、\sphinxstylestrong{黒基調の画面} にすることでPCの光害を抑制している。

使い方は見れば分かると思うが、「びゅーん」が高速回転、「のろのろ」が低速回転だ。また、本番で画面を暗くしているとマウス操作が大変なので、日周はキーボードでも操作できる。\sphinxcode{C}: 高速逆転、\sphinxcode{V}: 低速逆転、\sphinxcode{B}: 停止、\sphinxcode{N}: 低速順回転、\sphinxcode{M}: 高速順回転 である。

総じて24日電の雰囲気がよく出ており大変分かりやすいものの、回転方向が少し把握しにくい。なお、アプリ名称は往時の天文部の「備品などに駅名をつける」習慣に則ったもので、「ふじさわ」は制作者の地元であるらしい。


\section{Chichibu(2014)}
\label{\detokenize{nissyu-idohen/pc-software-history:chichibu-2014}}
\sphinxincludegraphics{{chichibu}.png}

25伊藤氏が開発したアプリ。他にない特色として、25ソフト専用のモードが用意され、ボタンを押すだけでシナリオで要求された動きを実現できることがある。

また、23の\sphinxcode{NisshuidohenController2}と24の\sphinxcode{Fujisawa}の画面もそのまま移植され、それぞれの機能が利用できる。本番でも、ライブ解説時には\sphinxcode{Fujisawa}を使っていたようだ。

\sphinxincludegraphics{{chichibu_2}.png}

フルスクリーン状態で起動することで、以前より更に画面の光漏れを抑えている。ただし、ソフト内に終了ボタンがないうえタイトルバーも見えないので、プログラムを終了させる際は\sphinxcode{Alt}+\sphinxcode{F4}を押すなどショートカットキーを使うしかない。


\section{Ogose(2016)}
\label{\detokenize{nissyu-idohen/pc-software-history:ogose-2016}}
\sphinxincludegraphics{{ogose}.png}

27日電の伊東が開発した。これまでのUIの問題点を洗い出した上で、改善すべく様々な変更を加えている。デザイン部分(\sphinxcode{MainWindow.xaml})は一から作り直したが、コマンド文字列生成は\sphinxcode{NisshuidohenController.cs}を継続使用した。

指定できる速度が各軸4段階に増えたことで、多彩な演出が可能となった。また、速度指定のボタンを回転スタート/ストップボタンとは別に用意したため、回転を止めずとも速度を変更できる。

ウィンドウモードとフルスクリーンモードをボタンで切り替えられる機能も実装した。また、フルスクリーンボタンの横にある「公演モード」ボタンは、使用できる機能を「日周進める」に限定し誤操作を防止する機能である。キーボード操作などにより意図しない状態になるバグが存在するので注意。

思いがけないことに、ボタンを十字に配置したことで、ゲームコントローラーのボタンと同様の配置となった。本番ではゲームコントローラーを実際に使用し、慣れていない人でも操作ができるという恩恵があった。

実装についてなど、詳細は{\hyperref[\detokenize{nissyu-idohen/pc-software::doc}]{\sphinxcrossref{\DUrole{doc}{外部制御アプリの記事}}}}に示すこととする。


\chapter{日周緯度変(Ogoseの実装解説)}
\label{\detokenize{nissyu-idohen/pc-software-code:ogose}}\label{\detokenize{nissyu-idohen/pc-software-code::doc}}\begin{itemize}
\item {} 
書いた人: Kenichi Ito(nichiden\_27)

\item {} 
更新日時: 2017/03/06

\item {} 
実行に必要な知識・技能: Windows GUI開発、C\#、WPF、Visual Studioの操作

\item {} 
難易度: 3: 練習・勉強が必要

\item {} 
情報の必須度: 3: 必要な場合がある

\end{itemize}


\section{概要}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id1}}
{\hyperref[\detokenize{nissyu-idohen/pc-software::doc}]{\sphinxcrossref{\DUrole{doc}{日周緯度変(外部制御アプリ)}}}}から\sphinxcode{Ogose}の実装解説を分離した記事です。

\sphinxcode{Ogose}のソースコードを読む、あるいは書き換える際に参考にしてください。


\section{ファイル構成}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id2}}
\sphinxcode{Ogose}のソースファイル等は、\sphinxcode{Ogose}フォルダ内に入っている。いかにファイル・ディレクトリ構成の抜粋を示す。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Ogose
├-- Ogose
\textbar{}   ├-- App.config
\textbar{}   ├-- App.xaml
\textbar{}   ├-- App.xaml.cs
\textbar{}   ├-- MainWindow.xaml
\textbar{}   ├-- MainWindow.xaml.cs
\textbar{}   ├-- NisshuidohenController.cs
\textbar{}   ├-- Ogose.csproj
\textbar{}   ├-- Properties
\textbar{}   \textbar{}   └-- (省略)
\textbar{}   ├-- bin
\textbar{}   \textbar{}   ├-- Debug
\textbar{}   \textbar{}   \textbar{}   ├-- Ogose.exe
\textbar{}   \textbar{}   \textbar{}   └-- (省略)
\textbar{}   \textbar{}   └-- Release
\textbar{}   \textbar{}       ├-- Ogose.exe
\textbar{}   \textbar{}       └-- (省略)
\textbar{}   ├-- main\PYGZus{}projector\PYGZus{}27\PYGZus{}w.png
\textbar{}   └-- obj
\textbar{}       └-- (省略)
└-- Ogose.sln
\end{sphinxVerbatim}

見た目には複雑で身構えてしまうかもしれない。
ただ、\sphinxcode{Visual Studio(以下VS)}でプロジェクトを作成すると自動で生成されるファイルがほとんどで、実際に開発者が触るべきファイルは多くない。

\sphinxcode{Ogose}直下には\sphinxcode{Ogose.sln}がある。これは「ソリューション(開発プロジェクトをまとめたもの)」の状態を管理している。
slnファイルをダブルクリックするか、VS内の読み込みメニューで選択してあげれば\sphinxcode{Ogose}の各ファイルを閲覧できる。

\sphinxcode{Ogose}の下に更に\sphinxcode{Ogose}ディレクトリがあり、この中にソースコードなどが収められている。
このうち、開発で実際に触ったのは\sphinxcode{App.xaml} \sphinxcode{MainWindow.xaml} \sphinxcode{MainWindow.xaml.cs} \sphinxcode{NisshuidohenController.cs}の四つのみである。

\sphinxcode{Ogose/Ogose/bin/}以下には、ビルドで生成された\sphinxcode{.exe}ファイルが格納される。
\sphinxcode{Debug}と\sphinxcode{Release}は適当に使い分ければいい。exeの他にも様々なファイルが吐き出されるが、基本的には\sphinxcode{Ogose.exe}単体で動作する。

以下、ソースコードを簡単に解説する。WPF開発の基本的な知識全てに触れるとは限らないので、よく理解できない部分はググるなどして補完してもらいたい。


\section{App.xaml}
\label{\detokenize{nissyu-idohen/pc-software-code:app-xaml}}
\sphinxcode{App.xaml}や\sphinxcode{App.xaml.cs}の内容は、GUIのみならずアプリケーション全体に適用される。
何も書かなくても問題ないが、\sphinxcode{Ogose}では画面デザインに関する記述を全てこちらに分離した。{\hyperref[\detokenize{nissyu-idohen/pc-software-code:mainwindow-xaml}]{\emph{MainWindow.xaml}}}が長くなりすぎないようにするのが目的である。

XAML(ざむる)は、XMLをベースとしたGUIの記述言語である。XMLのタグを用いて階層状に指示を書けるようになっている。
なお、\sphinxcode{\textless{}\textgreater{}}で囲まれた単位は「タグ」とも「要素」とも言うが、GUIの要素と混同する危険があるので、ここでは「タグ」に統一する。

\sphinxcode{\textless{}Application\textgreater{}}タグには色々とおまじないが書いてあるが、気にする必要はない。その下の\sphinxcode{\textless{}Application.Resources\textgreater{}}内からがコードの本番だ。


\subsection{ブラシ}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id3}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZlt{}!\PYGZhy{}\PYGZhy{}}\PYG{c}{  App.xaml }\PYG{c}{\PYGZhy{}\PYGZhy{}\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}SolidColorBrush} \PYG{n+na}{x:Key=}\PYG{l+s}{\PYGZdq{}WindowBackground\PYGZdq{}} \PYG{n+na}{Color=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}FF111111\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}SolidColorBrush} \PYG{n+na}{x:Key=}\PYG{l+s}{\PYGZdq{}ButtonNormalBackground\PYGZdq{}} \PYG{n+na}{Color=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}AA444444\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}SolidColorBrush} \PYG{n+na}{x:Key=}\PYG{l+s}{\PYGZdq{}ButtonHoverBackground\PYGZdq{}} \PYG{n+na}{Color=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}FF334433\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}SolidColorBrush} \PYG{n+na}{x:Key=}\PYG{l+s}{\PYGZdq{}ButtonNormalForeground\PYGZdq{}} \PYG{n+na}{Color=}\PYG{l+s}{\PYGZdq{}White\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}SolidColorBrush} \PYG{n+na}{x:Key=}\PYG{l+s}{\PYGZdq{}ButtonDisableBackground\PYGZdq{}} \PYG{n+na}{Color=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}AA222222\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}SolidColorBrush} \PYG{n+na}{x:Key=}\PYG{l+s}{\PYGZdq{}ButtonDisableForeground\PYGZdq{}} \PYG{n+na}{Color=}\PYG{l+s}{\PYGZdq{}SlateGray\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}SolidColorBrush} \PYG{n+na}{x:Key=}\PYG{l+s}{\PYGZdq{}ButtonNormalBorder\PYGZdq{}} \PYG{n+na}{Color=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}FF707070\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}

\PYG{n+nt}{\PYGZlt{}LinearGradientBrush} \PYG{n+na}{x:Key=}\PYG{l+s}{\PYGZdq{}TextBoxBorder\PYGZdq{}} \PYG{n+na}{EndPoint=}\PYG{l+s}{\PYGZdq{}0,20\PYGZdq{}} \PYG{n+na}{MappingMode=}\PYG{l+s}{\PYGZdq{}Absolute\PYGZdq{}} \PYG{n+na}{StartPoint=}\PYG{l+s}{\PYGZdq{}0,0\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}GradientStop} \PYG{n+na}{Color=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}ABADB3\PYGZdq{}} \PYG{n+na}{Offset=}\PYG{l+s}{\PYGZdq{}0.05\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}GradientStop} \PYG{n+na}{Color=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}E2E3EA\PYGZdq{}} \PYG{n+na}{Offset=}\PYG{l+s}{\PYGZdq{}0.07\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}GradientStop} \PYG{n+na}{Color=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}E3E9EF\PYGZdq{}} \PYG{n+na}{Offset=}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/LinearGradientBrush\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxstylestrong{ブラシ} は、色などのデザインに名前(\sphinxcode{x:Key})をつけて使い回せるようにしたものである。各色の役割が明確になるし、後からの変更も楽なので積極的に利用した。
\sphinxcode{SolidColorBrush}は単色のブラシ、\sphinxcode{LinearGradientBrush}はグラデーションのブラシである。

配色が気に入らなければ、ここの色指定を変えれば良い。
色は名称で指定しても良いし(\href{http://www.atmarkit.co.jp/fdotnet/dotnettips/1071colorname/colorname.html\#colorsample}{色一覧})、Webなどでお馴染みの16進数で更に細かく決めることもできる。
ここでは\sphinxcode{ARGB}というRGBに加えアルファ値(透過度)も指定する方式で書いているので注意。例えば\sphinxcode{\#FF111111}なら、不透明で\{R,G,B\} =　\{17,17,17\}の色を指す。


\subsection{コントロールテンプレート}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id4}}
\sphinxstylestrong{コントロールテンプレート} は、コントロール(ボタンやテキストエリアなど)のテンプレートである。
この中にボタンなどの見た目を書いておくと使い回しが効く。今あるコントロールテンプレートとその用途は以下の通り。
\begin{itemize}
\item {} 
``NormalToggleButton'' ... 日周緯度変回転用のトグルボタン

\item {} 
``ComboBoxToggleButton'' ... 接続するシリアルポートを選択するコンボボックス

\end{itemize}

また、\sphinxcode{\textless{}ControlTemplate.Triggers\textgreater{}}タグ内で「トリガー」を指定できる。
トリガーは、特定のイベントが起きたら動的にコントロールの見た目を変更する機能だ。
マウスでポイントした時やクリックした時に色が変わると、操作の結果がユーザーに視覚的に伝わる。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZlt{}!\PYGZhy{}\PYGZhy{}}\PYG{c}{  App.xaml }\PYG{c}{\PYGZhy{}\PYGZhy{}\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}ControlTemplate.Triggers}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Trigger} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}IsMouseOver\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}true\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{TargetName=}\PYG{l+s}{\PYGZdq{}InnerBackground\PYGZdq{}}  \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}Fill\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}FF222288\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/Trigger\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Trigger} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}IsChecked\PYGZdq{}}  \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}true\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}Content\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}停止\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{TargetName=}\PYG{l+s}{\PYGZdq{}InnerBackground\PYGZdq{}}  \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}Fill\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}\PYGZsh{}FF111144\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/Trigger\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Trigger} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}IsEnabled\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}false\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{TargetName=}\PYG{l+s}{\PYGZdq{}Content\PYGZdq{}} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}TextBlock.Foreground\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}\PYGZob{}StaticResource ButtonDisableForeground\PYGZcb{}\PYGZdq{}}  \PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{TargetName=}\PYG{l+s}{\PYGZdq{}InnerBackground\PYGZdq{}} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}Fill\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}\PYGZob{}StaticResource ButtonDisableBackground\PYGZcb{}\PYGZdq{}}  \PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/Trigger\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/ControlTemplate.Triggers\PYGZgt{}}
\end{sphinxVerbatim}

例として、\sphinxcode{"NormalToggleButton"}のトリガー定義を紹介する。
マウスポインタが乗った時、Checked(ON)状態になった時でそれぞれ''InnerBackground''の色を変更するようになっている。
\sphinxcode{Property="IsEnabled"}は、ボタンが有効(=操作できる)かを示しており、これが\sphinxcode{false}の時は、文字・背景の色をグレー調にしてクリックできないことをアピールする。


\subsection{スタイル}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id5}}
\sphinxstylestrong{スタイル} には、要素の外観を定義できる。
前項のコントロールテンプレートに比べ機能が制限され、より個別の要素に対して用いる。

スタイルの適用の仕方はいくつかある。\sphinxstylestrong{\sphinxcode{TargetType}に要素の種類を入れると、同じ種類の要素全てに適用される}。
以下は\sphinxcode{Window}の見た目を指定している例。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZlt{}!\PYGZhy{}\PYGZhy{}}\PYG{c}{  App.xaml }\PYG{c}{\PYGZhy{}\PYGZhy{}\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}Style} \PYG{n+na}{TargetType=}\PYG{l+s}{\PYGZdq{}Window\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}Background\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}\PYGZob{}StaticResource WindowBackground\PYGZcb{}\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}Height\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}600\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}MinHeight\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}600\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}Width\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}700\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}MinWidth\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}700\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/Style\PYGZgt{}}
\end{sphinxVerbatim}

\sphinxcode{\textless{}Setter\textgreater{}}タグはプロパティを操作するために使う。\sphinxcode{Property}にプロパティの名前、\sphinxcode{Value}に値を入れるだけである。
\sphinxcode{Value}は実際の値でもいいし、ブラシなど他で定義したリソースを与えてもよい。

\sphinxcode{\textless{}Setter\textgreater{}}の中には更に様々な機能を持ったタグを入れられる。\sphinxcode{\textless{}ControlTemplate\textgreater{}}が入っていることもあるし、\sphinxcode{\textless{}Style.Triggers\textgreater{}}タグでトリガーを設定することもできる。
複雑な使い方は筆者もよく把握していないので、頑張ってググって貰いたい。

もう一つのスタイル適用方法は、\sphinxstylestrong{\sphinxcode{x:Key}プロパティ} を用いることだ。\sphinxcode{\textless{}Style\textgreater{}}タグに\sphinxcode{x:Key="hogefuga"}のように分かりやすい名前をつけておく。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZlt{}!\PYGZhy{}\PYGZhy{}}\PYG{c}{  App.xaml }\PYG{c}{\PYGZhy{}\PYGZhy{}\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}Style} \PYG{n+na}{x:Key=}\PYG{l+s}{\PYGZdq{}DiurnalPlusButton\PYGZdq{}} \PYG{n+na}{TargetType=}\PYG{l+s}{\PYGZdq{}ToggleButton\PYGZdq{}} \PYG{n+na}{BasedOn=}\PYG{l+s}{\PYGZdq{}\PYGZob{}StaticResource ToggleButton\PYGZcb{}\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}Content\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}日周戻す\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}FontSize\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}18\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/Style\PYGZgt{}}

\PYG{n+nt}{\PYGZlt{}Style} \PYG{n+na}{x:Key=}\PYG{l+s}{\PYGZdq{}DiurnalMinusButton\PYGZdq{}} \PYG{n+na}{TargetType=}\PYG{l+s}{\PYGZdq{}ToggleButton\PYGZdq{}} \PYG{n+na}{BasedOn=}\PYG{l+s}{\PYGZdq{}\PYGZob{}StaticResource DiurnalPlusButton\PYGZcb{}\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Setter} \PYG{n+na}{Property=}\PYG{l+s}{\PYGZdq{}Content\PYGZdq{}} \PYG{n+na}{Value=}\PYG{l+s}{\PYGZdq{}日周進める\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}/Style\PYGZgt{}}
\end{sphinxVerbatim}

そして、適用したいボタンなどに\sphinxcode{Style="\{StaticResource hogefuga\}"}などと指定すれば該当する\sphinxcode{x:Key}を持つスタイルが適用される。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZlt{}!\PYGZhy{}\PYGZhy{}}\PYG{c}{  MainWindow.xaml }\PYG{c}{\PYGZhy{}\PYGZhy{}\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}ToggleButton} \PYG{n+na}{x:Name=}\PYG{l+s}{\PYGZdq{}diurnalPlusButton\PYGZdq{}} \PYG{n+na}{Style=}\PYG{l+s}{\PYGZdq{}\PYGZob{}StaticResource DiurnalPlusButton\PYGZcb{}\PYGZdq{}} \PYG{n+na}{Grid.Row=}\PYG{l+s}{\PYGZdq{}2\PYGZdq{}} \PYG{n+na}{Grid.Column=}\PYG{l+s}{\PYGZdq{}0\PYGZdq{}}
               \PYG{n+na}{Command=}\PYG{l+s}{\PYGZdq{}\PYGZob{}x:Static local:MainWindow.diurnalPlusButtonCommand\PYGZcb{}\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
\end{sphinxVerbatim}

上の\sphinxcode{App.xaml}のコードでは、\sphinxstylestrong{スタイルの継承} という機能も活用している。
\sphinxcode{BasedOn}プロパティに基にしたいスタイルの\sphinxcode{x:Key}を指定すると、そのスタイルの中身を引き継いだり、部分的に書き換えたりできる。

例えば、\sphinxcode{"DiurnalMinusButton"}スタイルは\sphinxcode{"DiurnalPlusButton"}スタイルを継承したので、\sphinxcode{FontSize}について再度記述する必要がない。
一方で、ボタンに表示する文字は変更したいので、\sphinxcode{Content}を書き換えている。


\section{MainWindow.xaml}
\label{\detokenize{nissyu-idohen/pc-software-code:mainwindow-xaml}}
メインのウィンドウの構造を記述する。
といっても\sphinxcode{Ogose}には一つしかウィンドウがないので、配置を変えたい場合はこれを編集すればいい。
UIのデザインについてもこの中に書けるが、たいへん長いので{\hyperref[\detokenize{nissyu-idohen/pc-software-code:app-xaml}]{\emph{App.xaml}}}に移した。


\subsection{編集方法について}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id6}}
ウィンドウの見た目はXAMLのコードだけで自在に操れるが、VSではより便利に、実際の画面をプレビューしながらドラッグ\&ドロップで編集することもできる。

\sphinxincludegraphics{{mainwindow-xaml}.png}

GUIでの編集は手軽で初心者にも扱いやすいが、コードが自動生成されるので手で書くよりも読みにくくなりがちだ。
また、数値を細かく決めたい場合はコードを直接編集した方が早い。
図のように画面プレビューとコードは並べて表示できるので、双方の利点を使い分けるとよかろう。


\subsection{グリッド}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id7}}
WPFのレイアウト要素はいくつかあるが、\sphinxcode{Ogose}では\sphinxcode{\textless{}Grid\textgreater{}}タグを使ってレイアウトしている。
\sphinxstylestrong{グリッド} は、画面を格子状に分割してその中に要素を配置していくことができる。
いちいち行や列を定義せねばならず面倒だが、サイズを相対的に決められるので、ウィンドウを大きくしたときボタンも拡大されるというメリットがある。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZlt{}!\PYGZhy{}\PYGZhy{}}\PYG{c}{ MainWindow.xaml }\PYG{c}{\PYGZhy{}\PYGZhy{}\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}Grid} \PYG{n+na}{x:Name=}\PYG{l+s}{\PYGZdq{}MainGrid\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Grid.RowDefinitions}\PYG{n+nt}{\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}RowDefinition} \PYG{n+na}{Height=}\PYG{l+s}{\PYGZdq{}1*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}RowDefinition} \PYG{n+na}{Height=}\PYG{l+s}{\PYGZdq{}30\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}RowDefinition} \PYG{n+na}{Height=}\PYG{l+s}{\PYGZdq{}40*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}RowDefinition} \PYG{n+na}{Height=}\PYG{l+s}{\PYGZdq{}2*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}RowDefinition} \PYG{n+na}{Height=}\PYG{l+s}{\PYGZdq{}1*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/Grid.RowDefinitions\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Grid.ColumnDefinitions}\PYG{n+nt}{\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}ColumnDefinition} \PYG{n+na}{Width=}\PYG{l+s}{\PYGZdq{}1*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}ColumnDefinition} \PYG{n+na}{Width=}\PYG{l+s}{\PYGZdq{}60*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}ColumnDefinition} \PYG{n+na}{Width=}\PYG{l+s}{\PYGZdq{}20*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}ColumnDefinition} \PYG{n+na}{Width=}\PYG{l+s}{\PYGZdq{}20*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}ColumnDefinition} \PYG{n+na}{Width=}\PYG{l+s}{\PYGZdq{}1*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}/Grid.ColumnDefinitions\PYGZgt{}}
    \PYG{n+nt}{\PYGZlt{}Grid} \PYG{n+na}{x:Name=}\PYG{l+s}{\PYGZdq{}HeaderGrid\PYGZdq{}} \PYG{n+na}{Grid.Row=}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}} \PYG{n+na}{Grid.Column=}\PYG{l+s}{\PYGZdq{}1\PYGZdq{}} \PYG{n+na}{Grid.ColumnSpan=}\PYG{l+s}{\PYGZdq{}3\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}Grid.ColumnDefinitions}\PYG{n+nt}{\PYGZgt{}}
            \PYG{n+nt}{\PYGZlt{}ColumnDefinition} \PYG{n+na}{Width=}\PYG{l+s}{\PYGZdq{}9*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
            \PYG{n+nt}{\PYGZlt{}ColumnDefinition} \PYG{n+na}{Width=}\PYG{l+s}{\PYGZdq{}1*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
            \PYG{n+nt}{\PYGZlt{}ColumnDefinition} \PYG{n+na}{Width=}\PYG{l+s}{\PYGZdq{}13*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
            \PYG{n+nt}{\PYGZlt{}ColumnDefinition} \PYG{n+na}{Width=}\PYG{l+s}{\PYGZdq{}7*\PYGZdq{}}\PYG{n+nt}{/\PYGZgt{}}
        \PYG{n+nt}{\PYGZlt{}/Grid.ColumnDefinitions\PYGZgt{}}
\end{sphinxVerbatim}

上のコード片は、グリッドを定義している例である。
一意の\sphinxcode{x:Name}を付けて\sphinxcode{\textless{}Grid\textgreater{}}を宣言したら、\sphinxcode{\textless{}Grid.RowDefinitions\textgreater{}}で行を、\sphinxcode{\textless{}Grid.ColumnDefinitions\textgreater{}}で列を定義する。


\subsubsection{グリッドの使い方}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id8}}
それぞれの中に行・列を欲しいだけ並べれば良いのだが、\sphinxstylestrong{高さや幅の指定} にポイントがある。
数値のみを書くとピクセル数を表すが、\sphinxcode{数値*}とすると相対サイズを表せるのだ。
例えば、\sphinxcode{Height="1*"}の行と\sphinxcode{Height="2*"}の行だけがある場合、グリッドは1:2の比率で分割される。

また、コード例では使っていないが\sphinxcode{Auto}を指定すると、中に配置した子要素のサイズに合わせてくれる。
ピクセル指定、相対指定、Auto指定は混ぜて書いても問題ない。
画面プレビューで行や列を分割した場合、サイズが単純な数値にならないので適宜コード側で修正するといいだろう。

\sphinxstylestrong{グリッドの中に要素を置く} 時は、画面プレビュー上で設置したい場所に動かすだけで良い。
ただし、グリッドは入れ子にすることもでき(コード例では\sphinxcode{MainGrid}の下に\sphinxcode{HeaderGrid}を入れてある)、意図した階層に置けないことも多々ある。
その場合は、望みの階層に要素の定義をコピペした上で、\sphinxcode{Grid.Row}と\sphinxcode{Grid.Column}プロパティに何行何列目かを指定する。
両プロパティは\sphinxstylestrong{0始まり} なので要注意。\sphinxcode{Grid.Row="1" Grid.Column="1"}なら2行2列目だ。

要素が横に長く、\sphinxstylestrong{複数の列に渡って配置} したいーそんな時は、\sphinxcode{Grid.RowSpan}や\sphinxcode{Grid.ColumnSpan}を使おう。
それぞれに指定した数だけ要素が占める場所が下方向・右方向に伸びる。
これは、画面プレビューで操作している時に勝手に追加されていることもあるので、やはりコード側で直してあげよう。


\subsection{UI要素}
\label{\detokenize{nissyu-idohen/pc-software-code:ui}}
個別のUI要素については実際にコードを見ていただく方が早い。
\sphinxcode{Ogose}では\sphinxcode{ComboBox}、\sphinxcode{ToggleButton}、\sphinxcode{RadioButton}、\sphinxcode{CheckBox}などを使い分けている。
それぞれの動作を規定するコードについては、{\hyperref[\detokenize{nissyu-idohen/pc-software-code:mainwindow-xaml-cs}]{\emph{MainWindow.xaml.cs}}}の項で扱う。

少し説明が必要なのは、\sphinxcode{RadioButton}についてだ。
\sphinxstylestrong{ラジオボタン} というと、
◎ 選択肢1
◎ 選択肢2
のようなデザインが普通だ。

しかし、\sphinxcode{Ogose}では縦に並べたり横に並べたりするので、横の二重丸がなく/普通のボタンと同じ見た目で/全体がクリック可能 である方が都合がよい。
実は、これには複雑なコーディングは必要なく、トグルボタン用のスタイルを適用してやるだけで済む。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZlt{}!\PYGZhy{}\PYGZhy{}}\PYG{c}{  App.xaml }\PYG{c}{\PYGZhy{}\PYGZhy{}\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}Style} \PYG{n+na}{TargetType=}\PYG{l+s}{\PYGZdq{}RadioButton\PYGZdq{}} \PYG{n+na}{BasedOn=}\PYG{l+s}{\PYGZdq{}\PYGZob{}StaticResource ToggleButton\PYGZcb{}\PYGZdq{}}\PYG{n+nt}{\PYGZgt{}}
\end{sphinxVerbatim}

これは、\sphinxcode{RadioButton}クラスが\sphinxcode{ToggleButton}クラスを継承しているため、共通のスタイル指定が使えることによる
(参考にした記事: \href{http://neareal.net/index.php?Programming\%2F.NetFramework\%2FWPF\%2FRadioToggleButton}{RadioButtonなToggleButtonを実現する})。


\section{MainWindow.xaml.cs}
\label{\detokenize{nissyu-idohen/pc-software-code:mainwindow-xaml-cs}}
\sphinxcode{MainWindow.xaml}のコードビハインドである。C\#で書かれている。
日電のWindowsアプリケーションは代々C\#なので、宗教上やむを得ない事情がなければC\#を読み書きできるようになろう。

とはいえ、VSのコード補完(\sphinxcode{IntelliSense})が凄く優秀なので、コードを書いていて苦労することはあまりなさそうだ。
筆者もC\#経験はないが、言語使用についてはfor文を少しググったくらいで不便を感じることは少なかった。

コード中にやたら\sphinxcode{\textless{}summary\textgreater{}\textless{}/summary\textgreater{}}で囲まれたコメントを目にすると思うが、これはVSのドキュメント自動生成機能の推奨XMLタグらしい。
ドキュメントを作るかは別として、面倒でなければこの形式のコメントにして損はなさそうだ。

400行近いコードの全てを解説することはしないので、コードだけでは分かりにくいと思われる項目のみを以下に掲載する。


\subsection{コマンド}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id9}}
\sphinxstylestrong{コマンド} とは、ユーザの操作を抽象化したものである。
例えば、Wordで編集していてペースト操作をしたいとき、どうするか考えてみよう。
ショートカットキーを知っていれば\sphinxcode{Ctrl(Command)}+\sphinxcode{V}を叩くだろうし、右クリックしてペーストを選ぶ人もいるだろう。
メニューバーからペーストメニューを選択してもペーストできる。
操作はいろいろだが、結果として呼ばれる処理は同一なのだ。
この仕組みがコマンドで、WPFでは\sphinxcode{ICommand}というインターフェースで実現される。

無理にコマンドを使わずともアプリは作れるのだが、\sphinxcode{Ogose}のキーボード操作を実装する際、必要に迫られて導入した。
これまでと違い\sphinxcode{Ogose}の回転/停止ボタンはトグル式で、色やラベルが状態により変化する。
25までClickイベントを用いる方式では上手く行かなくなったのである(キー操作だと、外観を変えるべきボタンの名称を関数内で取得できないため...だった気がする)。

そこで、\sphinxcode{ICommand}を使うようにプログラムを書き直した。
時間がない中でやったので、かなり汚いコードになってしまった。
今後書き換える際はぜひ何とかして欲しい。


\subsubsection{コマンドの使い方}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id10}}
コマンドは高機能の代わりに難解なので、使い始めるときは\href{http://techoh.net/wpf-make-command-in-5steps/}{この記事}あたりを参考にした。

①まず、\sphinxcode{RoutedCommand}クラスを宣言する。絶賛コピペなので意味はよく知らない。
\sphinxcode{diurnalPlus}は日周を進めるという意味だ。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// \PYGZlt{}summary\PYGZgt{} RoutedCommand \PYGZlt{}/summary\PYGZgt{}}
\PYG{k}{public} \PYG{k}{readonly} \PYG{k}{static} \PYG{n}{RoutedCommand} \PYG{n}{diurnalPlusButtonCommand} \PYG{p}{=} \PYG{k}{new} \PYG{n}{RoutedCommand}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}diurnalPlusButtonCommand\PYGZdq{}}\PYG{p}{,} \PYG{k}{typeof}\PYG{p}{(}\PYG{n}{MainWindow}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

②この状態ではまだコマンドとボタン・処理が結びついていない。
CommandBindingという操作でこれらを紐付けする。これもコピペ。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// \PYGZlt{}summary\PYGZgt{}}
\PYG{c+c1}{/// MainWindowに必要なコマンドを追加する。コンストラクタで呼び出して下さい}
\PYG{c+c1}{/// \PYGZlt{}/summary\PYGZgt{}}
\PYG{k}{private} \PYG{k}{void} \PYG{n+nf}{initCommandBindings}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{diurnalPlusButton}\PYG{p}{.}\PYG{n}{CommandBindings}\PYG{p}{.}\PYG{n}{Add}\PYG{p}{(}\PYG{k}{new} \PYG{n}{CommandBinding}\PYG{p}{(}\PYG{n}{diurnalPlusButtonCommand}\PYG{p}{,} \PYG{n}{diurnalPlusButtonCommand\PYGZus{}Executed}\PYG{p}{,} \PYG{n}{toggleButton\PYGZus{}CanExecuted}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{c+c1}{/// (省略)}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

これをボタンの数だけ書き連ねる。
\sphinxcode{new CommandBinding()}に与えている引数は順に、コマンド・実行する関数・実行可能かを与える関数である。
三番目のコマンド実行可否は、コマンドを実行されては困る時のための仕組みだ。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{/// \PYGZlt{}summary\PYGZgt{} 各ボタンが操作できるかどうかを記憶 \PYGZlt{}/summary\PYGZgt{}}
\PYG{k}{private} \PYG{n}{Dictionary}\PYG{p}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,} \PYG{k+kt}{bool}\PYG{p}{\PYGZgt{}} \PYG{n}{isEnabled} \PYG{p}{=} \PYG{k}{new} \PYG{n}{Dictionary}\PYG{p}{\PYGZlt{}}\PYG{k+kt}{string}\PYG{p}{,} \PYG{k+kt}{bool}\PYG{p}{\PYGZgt{}}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}diurnalPlusButton\PYGZdq{}}\PYG{p}{,} \PYG{k}{true}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}diurnalMinusButton\PYGZdq{}}\PYG{p}{,} \PYG{k}{true}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}latitudePlusButton\PYGZdq{}}\PYG{p}{,} \PYG{k}{true}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
    \PYG{p}{\PYGZob{}}\PYG{l+s}{\PYGZdq{}latitudeMinusButton\PYGZdq{}}\PYG{p}{,} \PYG{k}{true}\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{private} \PYG{k}{void} \PYG{n+nf}{toggleButton\PYGZus{}CanExecuted}\PYG{p}{(}\PYG{k+kt}{object} \PYG{n}{sender}\PYG{p}{,} \PYG{n}{CanExecuteRoutedEventArgs} \PYG{n}{e}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{e}\PYG{p}{.}\PYG{n}{CanExecute} \PYG{p}{=} \PYG{n}{isEnabled}\PYG{p}{[}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ToggleButton}\PYG{p}{)}\PYG{n}{sender}\PYG{p}{)}\PYG{p}{.}\PYG{n}{Name}\PYG{p}{]}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

上手い方法が全然思いつかなかったので、\sphinxcode{isEnabled}という連想配列を作っておいて、呼び出し元ボタンの名前をもとに参照するようにした。
呼び出し元は、引数\sphinxcode{sender}に与えられて、\sphinxcode{ToggleButton}など元々のクラスに型変換するとプロパティを見たりできる。

③さて、\sphinxcode{private void initCommandBindings()}をプログラム開始時に実行しなければバインディングが適用されない。
\sphinxcode{MainWindow}のコンストラクタ内で呼び出しておく。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{public} \PYG{n+nf}{MainWindow}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{n}{InitializeComponent}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{n}{initCommandBindings}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

考えてみれば大したことはしてないので、コンストラクタの中に直接書いてしまっても良かったかもしれない。

④あとはXAML側でコマンドを呼び出せるようにするだけである。
\sphinxcode{\textless{}Window\textgreater{}}タグ内にローカルの名前空間(\sphinxcode{xmlns:local="clr-namespace:Ogose"})がなければ追加しておこう。
各コントロールの\sphinxcode{Command}プロパティにコマンドをコピペする。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c}{\PYGZlt{}!\PYGZhy{}\PYGZhy{}}\PYG{c}{ MainWindow.xaml }\PYG{c}{\PYGZhy{}\PYGZhy{}\PYGZgt{}}
\PYG{n+nt}{\PYGZlt{}ToggleButton} \PYG{n+na}{x:Name=}\PYG{l+s}{\PYGZdq{}diurnalPlusButton\PYGZdq{}} \PYG{n+na}{Style=}\PYG{l+s}{\PYGZdq{}\PYGZob{}StaticResource DiurnalPlusButton\PYGZcb{}\PYGZdq{}} \PYG{n+na}{Grid.Row=}\PYG{l+s}{\PYGZdq{}2\PYGZdq{}} \PYG{n+na}{Grid.Column=}\PYG{l+s}{\PYGZdq{}0\PYGZdq{}}
               \PYG{n+na}{Command=}\PYG{l+s}{\PYGZdq{}\PYGZob{}x:Static local:MainWindow.diurnalPlusButtonCommand\PYGZcb{}\PYGZdq{}} \PYG{n+nt}{/\PYGZgt{}}
\end{sphinxVerbatim}

これでクリック操作でコマンドが使えるようになる。


\subsubsection{キー操作でコマンドを実行する}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id11}}
ここまできたら、キー操作でもコマンドが実行されるようにしたい。
XAMLで\sphinxcode{\textless{}KeyBinding\textgreater{}}タグを使えば実現できるのだが、なんとこれではボタンがsenderにならない。
色々調べても対処法が見つからないので、結局キー操作イベントから無理やりコマンドを実行させるしかなかった。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{private} \PYG{k}{void} \PYG{n+nf}{Window\PYGZus{}KeyDown}\PYG{p}{(}\PYG{k+kt}{object} \PYG{n}{sender}\PYG{p}{,} \PYG{n}{KeyEventArgs} \PYG{n}{e}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k+kt}{var} \PYG{n}{target} \PYG{p}{=} \PYG{k}{new} \PYG{n}{ToggleButton}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
    \PYG{k}{switch} \PYG{p}{(}\PYG{n}{e}\PYG{p}{.}\PYG{n}{Key}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{k}{case} \PYG{n}{Key}\PYG{p}{.}\PYG{n}{W}\PYG{p}{:}
            \PYG{n}{latitudePlusButtonCommand}\PYG{p}{.}\PYG{n}{Execute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}KeyDown\PYGZdq{}}\PYG{p}{,} \PYG{n}{latitudePlusButton}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{k}{case} \PYG{n}{Key}\PYG{p}{.}\PYG{n}{A}\PYG{p}{:}
            \PYG{n}{diurnalPlusButtonCommand}\PYG{p}{.}\PYG{n}{Execute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}KeyDown\PYGZdq{}}\PYG{p}{,} \PYG{n}{diurnalPlusButton}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{k}{case} \PYG{n}{Key}\PYG{p}{.}\PYG{n}{S}\PYG{p}{:}
            \PYG{n}{latitudeMinusButtonCommand}\PYG{p}{.}\PYG{n}{Execute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}KeyDown\PYGZdq{}}\PYG{p}{,} \PYG{n}{latitudeMinusButton}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{break}\PYG{p}{;}
        \PYG{k}{case} \PYG{n}{Key}\PYG{p}{.}\PYG{n}{D}\PYG{p}{:}
            \PYG{n}{diurnalMinusButtonCommand}\PYG{p}{.}\PYG{n}{Execute}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}KeyDown\PYGZdq{}}\PYG{p}{,} \PYG{n}{diurnalMinusButton}\PYG{p}{)}\PYG{p}{;}
            \PYG{k}{break}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxcode{(コマンド名).Execute()}メソッドの第一引数は\sphinxcode{ExecutedRoutedEventArgs e}の\sphinxcode{Parameter}、第二引数は\sphinxcode{object sender}として渡される。
結局、\sphinxcode{sender}は第二引数に人力で指定した。

\sphinxcode{e.Parameter}というのは、仕様では「コマンドに固有の情報を渡す」とされていて、要は自由に使っていいようだ。
キーボード操作によるものかどうか、コマンドの処理で判定するために''KeyDown''という文字列(勝手に決めた)を渡している。


\subsubsection{コマンドごとの処理}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id12}}
最後に、CommandBindingでコマンドと紐付けた関数について書く。
日周を進めるボタンのものは以下のようになっている。

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{private} \PYG{k}{void} \PYG{n+nf}{diurnalPlusButtonCommand\PYGZus{}Executed}\PYG{p}{(}\PYG{k+kt}{object} \PYG{n}{sender}\PYG{p}{,} \PYG{n}{ExecutedRoutedEventArgs} \PYG{n}{e}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{e}\PYG{p}{.}\PYG{n}{Parameter} \PYG{p}{!}\PYG{p}{=} \PYG{k}{null} \PYG{p}{\PYGZam{}}\PYG{p}{\PYGZam{}} \PYG{n}{e}\PYG{p}{.}\PYG{n}{Parameter}\PYG{p}{.}\PYG{n}{ToString}\PYG{p}{(}\PYG{p}{)} \PYG{p}{=}\PYG{p}{=} \PYG{l+s}{\PYGZdq{}KeyDown\PYGZdq{}}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{p}{(}\PYG{p}{(}\PYG{n}{ToggleButton}\PYG{p}{)}\PYG{n}{sender}\PYG{p}{)}\PYG{p}{.}\PYG{n}{IsChecked} \PYG{p}{=} \PYG{p}{!}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ToggleButton}\PYG{p}{)}\PYG{n}{sender}\PYG{p}{)}\PYG{p}{.}\PYG{n}{IsChecked}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{sender} \PYG{k}{as} \PYG{n}{ToggleButton} \PYG{p}{!}\PYG{p}{=} \PYG{k}{null} \PYG{p}{\PYGZam{}}\PYG{p}{\PYGZam{}} \PYG{p}{(}\PYG{p}{(}\PYG{n}{ToggleButton}\PYG{p}{)}\PYG{n}{sender}\PYG{p}{)}\PYG{p}{.}\PYG{n}{IsChecked} \PYG{p}{=}\PYG{p}{=} \PYG{k}{false}\PYG{p}{)}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{emitCommand}\PYG{p}{(}\PYG{n}{nisshuidohenController}\PYG{p}{.}\PYG{n}{RotateDiurnalBySpeed}\PYG{p}{(}\PYG{l+m}{0}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{else}
    \PYG{p}{\PYGZob{}}
        \PYG{n}{emitCommand}\PYG{p}{(}\PYG{n}{nisshuidohenController}\PYG{p}{.}\PYG{n}{RotateDiurnalBySpeed}\PYG{p}{(}\PYG{n}{diurnal\PYGZus{}speed}\PYG{p}{)}\PYG{p}{)}\PYG{p}{;}
    \PYG{p}{\PYGZcb{}}
    \PYG{k}{if} \PYG{p}{(}\PYG{n}{sender} \PYG{k}{as} \PYG{n}{ToggleButton} \PYG{p}{!}\PYG{p}{=} \PYG{k}{null}\PYG{p}{)} \PYG{n}{toggleOppositeButton}\PYG{p}{(}\PYG{p}{(}\PYG{n}{ToggleButton}\PYG{p}{)}\PYG{n}{sender}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

どうしてこのような汚いコードになったのか弁解しておこう。


\subsection{イベントハンドラ}
\label{\detokenize{nissyu-idohen/pc-software-code:}}\label{\detokenize{nissyu-idohen/pc-software-code:id13}}
コマンド関連以外の残りのコードの大部分は、GUIおなじみのイベントハンドラである。
どんな時にどの関数が呼ばれるかは\sphinxcode{MainWindow.xaml}を見れば書いてあるので、ここでは触れない。


\subsection{NisshuidohenController.cs}
\label{\detokenize{nissyu-idohen/pc-software-code:nisshuidohencontroller-cs}}
TODO


\chapter{部品の買い方}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts::doc}}\label{\detokenize{buy_parts:id1}}\begin{itemize}
\item {} 
書いた人: Kenichi Ito(nichiden\_27)

\item {} 
更新日時: 2017/02/17

\item {} 
実行に必要な知識・技能: 秋葉原の土地勘

\item {} 
難易度: 2/少しやれば可能

\item {} 
情報の必須度: 3/必要な場合がある

\end{itemize}


\section{概要}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id2}}
回路を設計したら、部品を買いましょう。日電は重要なので予算はある程度優遇されますが、無限ではないのでできれば安く手に入れたいところです。通販は便利ですが、回数が重なると送料が無視できません。せっかく東京にいることだし、(2年秋に本郷に通う人は特に)秋葉原に通うことをオススメします。


\section{リアル店舗で買う}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id3}}

\subsection{全体の注意}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id4}}\begin{itemize}
\item {} 
ほぼ大体10割くらい秋葉です

\item {} 
自分の経験と勘に絶対の自信がある人以外は、買うものの\sphinxstylestrong{型番を}メモすべし
\begin{itemize}
\item {} 
名称が似ていても仕様が違ったりするので、型番で！！！

\end{itemize}

\item {} 
予備を絶対に買うこと
\begin{itemize}
\item {} 
壊れやすい部品(ICとか)は特に注意

\end{itemize}

\end{itemize}


\subsection{秋葉原電気街へのアクセス}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id5}}\begin{itemize}
\item {} 
駒場から

\end{itemize}
\begin{itemize}
\item {} 
山手線に乗り、秋葉原駅で降りる

\item {} 
銀座線に乗り、末広町駅で降りる

\end{itemize}
\begin{itemize}
\item {} 
本郷から
\begin{itemize}
\item {} 
徒歩で
\begin{itemize}
\item {} 
キャンパス内の位置にもよるが、30分足らずで移動できる

\item {} 
湯島や外神田を散策できるので、余裕のある日は是非

\end{itemize}

\item {} 
電車で
\begin{itemize}
\item {} 
根津駅から千代田線で新御茶ノ水駅まで移動

\item {} 
御茶ノ水からは徒歩

\item {} 
電気街は秋葉原駅より西側なので、思いのほか早く着く

\end{itemize}

\item {} 
バスで
\begin{itemize}
\item {} 
正門前や赤門前から\sphinxcode{茶51}系統で万世橋まで

\item {} 
本郷二食前から\sphinxcode{学07}系統で御茶ノ水駅前まで

\item {} 
徒歩が少なくて楽

\end{itemize}

\end{itemize}

\end{itemize}


\subsection{秋月電子通商}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id6}}
迷ったらここ。大抵のものは揃う上価格も安い。

ただ店内が狭く、平日昼間とか以外はすごく混雑するので注意。あと初見だと棚の配置が分からない。店内に地図があるはずなのでまずはゲットしよう。

\href{http://akizukidenshi.com/}{ネット通販}もあるので、店員に質問するときは通販のページを見せながらだとスムーズかと。とにかく部品の種類が凄いので見つからないと思ったら臆せず聞くべし。

ここの1000円のお楽しみ袋は伝説。初心者は勉強のために一回は買ったほうがいいだろう。


\subsection{千石電商}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id7}}
第二選択肢。秋月より広く三号店まであるものの、値段が全体的に高い。

秋月では揃わないコネクタや工具、切り売りの線材などはここで入手しよう。会計は各フロアで行わないといけないので注意。


\subsection{西川電子}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id8}}
総武線の高架近くにある店。「ネジ」と「コネクタ」に強いとされる。特にネジは一通り揃っているのは秋葉でもここくらいで、ハ◯ズなんかよりずっと安価で手に入るので近くを訪れた際はぜひ寄ろう。また、二階のヒロセや日圧のコネクタもたいへん充実している。

鈴商亡き今、秋葉の部品屋の「人情」みたいなものを感じられる店の一つかも。秋月や千石からすると閑散としていて心配だからみんな買いに行こうな。


\subsection{akibaLEDピカリ館}
\label{\detokenize{buy_parts:akibaled}}
秋月、千石と同じ並びにあるLED専門店(!)。夕方に通ると大変まぶしい。

秋月がパワーLEDの店頭在庫を切らしていた時に助けてもらった。値段は秋月と同じくらいだったと思う。とにかくLED関連の品揃えが凄いので時間が余ったら寄ると面白いかも。

なお、これを運営している（株）ピースコーポレーションは\href{http://www.led-paradise.com/}{LEDパラダイス}というLED通販サイトも手がけている。


\subsection{マルツ秋葉原本店/2号店}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id9}}
言わずと知れた通販大手だが店舗も全国に点在している。秋葉には本店と2号店があり、後者は秋月のはす向かいのブロックにあるので行きやすい。

近くに秋月千石の二強がある以上、ここで買い物する機会は多くないが、実は夜に真価を発揮する。秋葉の部品屋は19時くらいまでに軒並み閉まってしまうのに、ここは20:00まで開いている。今すぐに欲しい部品がある場合は駆けこもう。

また2号店の入り口近くには怪しい電源装置が特価で置いてあったりする。


\subsection{鈴商}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id10}}
今はないお店。千石〜秋月〜マルツの並びにあった老舗だが、\href{http://rocketnews24.com/2015/11/27/671666/}{2015年11月に閉店}。跡地には秋葉原神社という謎の施設が入った。


\subsection{ラジオデパート}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id11}}
総武線の高架沿い、西川電子と同じ並びにある。

行ったことがないので不明だが、多数の部品屋が入居しており、珍しい部品があるかもしれない。


\section{ネットで買う}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id12}}

\subsection{全体の注意}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id13}}\begin{itemize}
\item {} 
まともなサイトは仕様をまとめたデータシートをPDFなどで配布している
\begin{itemize}
\item {} 
必ず確認してから買おう!

\item {} 
データシートなしの部品には手を出さないのが無難

\end{itemize}

\item {} 
送料・納期を確認すべし

\item {} 
領収書は、納品書+支払いの証拠(振込の明細書など)とするのが基本
\begin{itemize}
\item {} 
電子部品は店の選択肢が少ないのでこうするしかないようです

\end{itemize}

\end{itemize}


\subsection{秋月電子通商}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id14}}
送料一律500円。お店に行く時にもここで予習しておくと便利。そのうち本店での商品位置情報が分かるアプリがリリースされるらしい。


\subsection{千石電商}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id15}}
これも予習に使える。送料432円。


\subsection{マルツ}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id16}}
大手だけどここで買ったことがないのであまり分からず。法人/官公庁向けの販売もしているのでサイト構成はちょっと敷居が高い感じ。

\href{http://www.marutsu.co.jp/pc/static/large\_order/led}{LEDの使い方}をはじめ、初心者\textasciitilde{}脱初心者向けの情報を提供していたりする。回路を組んでいて迷ったら探してみよう。

ケース加工やプリント基板加工もしており、しっかりとしたものを作りたい場合はお世話になるかも? 大学生協との提携も盛んで、学科や研究室で電子回路を扱う時に関わることになるのかもしれない。


\subsection{スイッチサイエンス}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id17}}
10000円以上で送料無料。海外向け製品など秋月で扱ってない商品もあるようだ。

電子工作やIoTの\href{https://connpass.com/search/?q=\%E3\%82\%B9\%E3\%82\%A4\%E3\%83\%83\%E3\%83\%81\%E3\%82\%B5\%E3\%82\%A4\%E3\%82\%A8\%E3\%83\%B3\%E3\%82\%B9}{イベント}を運営していたり、ブログに解説記事を載せたりと活動は活発。


\subsection{オリエンタルモータ}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id18}}
モータ専門の企業。日周・緯度変のモータとモータドライバは代々ここで買っている。

買い替える場合は型番を見て同じものを買えばいいだろう。ドライバはかなり高額だが、部室に予備があるしそもそも既製品なのであんまり壊れない。


\subsection{maxon}
\label{\detokenize{buy_parts:maxon}}
同じくモータ製造大手。データシートが詳細で、モータの勉強ができる。\href{http://academy.maxonjapan.co.jp/}{マクソンアカデミー}という解説記事群もある。


\subsection{ミスミ}
\label{\detokenize{buy_parts:}}\label{\detokenize{buy_parts:id19}}
金属系の部品なら買えないものはない、神のような存在。しかも送料無料(ネジ一本でも)。ただし法人格のアカウントがないと買えない。

日電で本格的に機械部品を扱うことは稀なので、無理に使うことはないかもしれない。


\chapter{索引}
\label{\detokenize{index:id2}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{索引}
\printindex
\end{document}